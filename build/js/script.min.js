!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t() : "function" == typeof define && define.amd ? define(t) : t();
}(0, function () {
  "use strict";

  function e(e) {
    var t = !0,
      n = !1,
      o = null,
      d = {
        text: !0,
        search: !0,
        url: !0,
        tel: !0,
        email: !0,
        password: !0,
        number: !0,
        date: !0,
        month: !0,
        week: !0,
        time: !0,
        datetime: !0,
        "datetime-local": !0
      };
    function i(e) {
      return !!(e && e !== document && "HTML" !== e.nodeName && "BODY" !== e.nodeName && "classList" in e && "contains" in e.classList);
    }
    function s(e) {
      e.classList.contains("focus-visible") || (e.classList.add("focus-visible"), e.setAttribute("data-focus-visible-added", ""));
    }
    function u(e) {
      t = !1;
    }
    function a() {
      document.addEventListener("mousemove", c), document.addEventListener("mousedown", c), document.addEventListener("mouseup", c), document.addEventListener("pointermove", c), document.addEventListener("pointerdown", c), document.addEventListener("pointerup", c), document.addEventListener("touchmove", c), document.addEventListener("touchstart", c), document.addEventListener("touchend", c);
    }
    function c(e) {
      e.target.nodeName && "html" === e.target.nodeName.toLowerCase() || (t = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mousedown", c), document.removeEventListener("mouseup", c), document.removeEventListener("pointermove", c), document.removeEventListener("pointerdown", c), document.removeEventListener("pointerup", c), document.removeEventListener("touchmove", c), document.removeEventListener("touchstart", c), document.removeEventListener("touchend", c));
    }
    document.addEventListener("keydown", function (n) {
      n.metaKey || n.altKey || n.ctrlKey || (i(e.activeElement) && s(e.activeElement), t = !0);
    }, !0), document.addEventListener("mousedown", u, !0), document.addEventListener("pointerdown", u, !0), document.addEventListener("touchstart", u, !0), document.addEventListener("visibilitychange", function (e) {
      "hidden" === document.visibilityState && (n && (t = !0), a());
    }, !0), a(), e.addEventListener("focus", function (e) {
      var n, o, u;
      i(e.target) && (t || (n = e.target, o = n.type, "INPUT" === (u = n.tagName) && d[o] && !n.readOnly || "TEXTAREA" === u && !n.readOnly || n.isContentEditable)) && s(e.target);
    }, !0), e.addEventListener("blur", function (e) {
      var t;
      i(e.target) && (e.target.classList.contains("focus-visible") || e.target.hasAttribute("data-focus-visible-added")) && (n = !0, window.clearTimeout(o), o = window.setTimeout(function () {
        n = !1;
      }, 100), (t = e.target).hasAttribute("data-focus-visible-added") && (t.classList.remove("focus-visible"), t.removeAttribute("data-focus-visible-added")));
    }, !0), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e.host ? e.host.setAttribute("data-js-focus-visible", "") : e.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add("js-focus-visible"), document.documentElement.setAttribute("data-js-focus-visible", ""));
  }
  if ("undefined" != typeof window && "undefined" != typeof document) {
    var t;
    window.applyFocusVisiblePolyfill = e;
    try {
      t = new CustomEvent("focus-visible-polyfill-ready");
    } catch (e) {
      (t = document.createEvent("CustomEvent")).initCustomEvent("focus-visible-polyfill-ready", !1, !1, {});
    }
    window.dispatchEvent(t);
  }
  "undefined" != typeof document && e(document);
});
!function (root, factory) {
  "function" == typeof define && define.amd ?
  // AMD. Register as an anonymous module unless amdModuleId is set
  define([], function () {
    return root.svg4everybody = factory();
  }) : "object" == typeof module && module.exports ?
  // Node. Does not work with strict CommonJS, but
  // only CommonJS-like environments that support module.exports,
  // like Node.
  module.exports = factory() : root.svg4everybody = factory();
}(this, function () {
  /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
  function embed(parent, svg, target) {
    // if the target exists
    if (target) {
      // create a document fragment to hold the contents of the target
      var fragment = document.createDocumentFragment(),
        viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
      // conditionally set the viewBox on the svg
      viewBox && svg.setAttribute("viewBox", viewBox);
      // copy the contents of the clone into the fragment
      for (
      // clone the target
      var clone = target.cloneNode(!0); clone.childNodes.length;) {
        fragment.appendChild(clone.firstChild);
      }
      // append the fragment into the svg
      parent.appendChild(fragment);
    }
  }
  function loadreadystatechange(xhr) {
    // listen to changes in the request
    xhr.onreadystatechange = function () {
      // if the request is ready
      if (4 === xhr.readyState) {
        // get the cached html document
        var cachedDocument = xhr._cachedDocument;
        // ensure the cached html document based on the xhr response
        cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}),
        // clear the xhr embeds list and embed each item
        xhr._embeds.splice(0).map(function (item) {
          // get the cached target
          var target = xhr._cachedTarget[item.id];
          // ensure the cached target
          target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)),
          // embed the target into the svg
          embed(item.parent, item.svg, target);
        });
      }
    },
    // test the ready state change immediately
    xhr.onreadystatechange();
  }
  function svg4everybody(rawopts) {
    function oninterval() {
      // while the index exists in the live <use> collection
      for (
      // get the cached <use> index
      var index = 0; index < uses.length;) {
        // get the current <use>
        var use = uses[index],
          parent = use.parentNode,
          svg = getSVGAncestor(parent),
          src = use.getAttribute("xlink:href") || use.getAttribute("href");
        if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src) {
          if (polyfill) {
            if (!opts.validate || opts.validate(src, svg, use)) {
              // remove the <use> element
              parent.removeChild(use);
              // parse the src and get the url and id
              var srcSplit = src.split("#"),
                url = srcSplit.shift(),
                id = srcSplit.join("#");
              // if the link is external
              if (url.length) {
                // get the cached xhr request
                var xhr = requests[url];
                // ensure the xhr request exists
                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []),
                // add the svg and id as an item to the xhr embeds list
                xhr._embeds.push({
                  parent: parent,
                  svg: svg,
                  id: id
                }),
                // prepare the xhr ready state change event
                loadreadystatechange(xhr);
              } else {
                // embed the local id into the svg
                embed(parent, svg, document.getElementById(id));
              }
            } else {
              // increase the index when the previous value was not "valid"
              ++index, ++numberOfSvgUseElementsToBypass;
            }
          }
        } else {
          // increase the index when the previous value was not "valid"
          ++index;
        }
      }
      // continue the interval
      (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
    }
    var polyfill,
      opts = Object(rawopts),
      newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
      webkitUA = /\bAppleWebKit\/(\d+)\b/,
      olderEdgeUA = /\bEdge\/12\.(\d+)\b/,
      edgeUA = /\bEdge\/.(\d+)\b/,
      inIframe = window.top !== window.self;
    polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
    // create xhr requests object
    var requests = {},
      requestAnimationFrame = window.requestAnimationFrame || setTimeout,
      uses = document.getElementsByTagName("use"),
      numberOfSvgUseElementsToBypass = 0;
    // conditionally start the interval if the polyfill is active
    polyfill && oninterval();
  }
  function getSVGAncestor(node) {
    for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode);) {}
    return svg;
  }
  return svg4everybody;
});
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e || self).autosize = t();
}(this, function () {
  var e = new Map();
  function t(t) {
    var o = e.get(t);
    o && o.destroy();
  }
  function o(t) {
    var o = e.get(t);
    o && o.update();
  }
  var r = null;
  return "undefined" == typeof window ? ((r = function (e) {
    return e;
  }).destroy = function (e) {
    return e;
  }, r.update = function (e) {
    return e;
  }) : ((r = function (t, o) {
    return t && Array.prototype.forEach.call(t.length ? t : [t], function (t) {
      return function (t) {
        if (t && t.nodeName && "TEXTAREA" === t.nodeName && !e.has(t)) {
          var o,
            r = null,
            n = window.getComputedStyle(t),
            i = (o = t.value, function () {
              s({
                testForHeightReduction: "" === o || !t.value.startsWith(o),
                restoreTextAlign: null
              }), o = t.value;
            }),
            l = function (o) {
              t.removeEventListener("autosize:destroy", l), t.removeEventListener("autosize:update", a), t.removeEventListener("input", i), window.removeEventListener("resize", a), Object.keys(o).forEach(function (e) {
                return t.style[e] = o[e];
              }), e.delete(t);
            }.bind(t, {
              height: t.style.height,
              resize: t.style.resize,
              textAlign: t.style.textAlign,
              overflowY: t.style.overflowY,
              overflowX: t.style.overflowX,
              wordWrap: t.style.wordWrap
            });
          t.addEventListener("autosize:destroy", l), t.addEventListener("autosize:update", a), t.addEventListener("input", i), window.addEventListener("resize", a), t.style.overflowX = "hidden", t.style.wordWrap = "break-word", e.set(t, {
            destroy: l,
            update: a
          }), a();
        }
        function s(e) {
          var o,
            i,
            l = e.restoreTextAlign,
            a = void 0 === l ? null : l,
            d = e.testForHeightReduction,
            u = void 0 === d || d,
            f = n.overflowY;
          if (0 !== t.scrollHeight && ("vertical" === n.resize ? t.style.resize = "none" : "both" === n.resize && (t.style.resize = "horizontal"), u && (o = function (e) {
            for (var t = []; e && e.parentNode && e.parentNode instanceof Element;) e.parentNode.scrollTop && t.push([e.parentNode, e.parentNode.scrollTop]), e = e.parentNode;
            return function () {
              return t.forEach(function (e) {
                var t = e[0],
                  o = e[1];
                t.style.scrollBehavior = "auto", t.scrollTop = o, t.style.scrollBehavior = null;
              });
            };
          }(t), t.style.height = ""), i = "content-box" === n.boxSizing ? t.scrollHeight - (parseFloat(n.paddingTop) + parseFloat(n.paddingBottom)) : t.scrollHeight + parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth), "none" !== n.maxHeight && i > parseFloat(n.maxHeight) ? ("hidden" === n.overflowY && (t.style.overflow = "scroll"), i = parseFloat(n.maxHeight)) : "hidden" !== n.overflowY && (t.style.overflow = "hidden"), t.style.height = i + "px", a && (t.style.textAlign = a), o && o(), r !== i && (t.dispatchEvent(new Event("autosize:resized", {
            bubbles: !0
          })), r = i), f !== n.overflow && !a)) {
            var c = n.textAlign;
            "hidden" === n.overflow && (t.style.textAlign = "start" === c ? "end" : "start"), s({
              restoreTextAlign: c,
              testForHeightReduction: !0
            });
          }
        }
        function a() {
          s({
            testForHeightReduction: !0,
            restoreTextAlign: null
          });
        }
      }(t);
    }), t;
  }).destroy = function (e) {
    return e && Array.prototype.forEach.call(e.length ? e : [e], t), e;
  }, r.update = function (e) {
    return e && Array.prototype.forEach.call(e.length ? e : [e], o), e;
  }), r;
});
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e();
}(this, function () {
  "use strict";

  const t = new Map(),
    e = {
      set(e, i, n) {
        t.has(e) || t.set(e, new Map());
        const s = t.get(e);
        s.has(i) || 0 === s.size ? s.set(i, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
      },
      get: (e, i) => t.has(e) && t.get(e).get(i) || null,
      remove(e, i) {
        if (!t.has(e)) return;
        const n = t.get(e);
        n.delete(i), 0 === n.size && t.delete(e);
      }
    },
    i = "transitionend",
    n = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)), t),
    s = t => {
      t.dispatchEvent(new Event(i));
    },
    o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
    r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(n(t)) : null,
    a = t => {
      if (!o(t) || 0 === t.getClientRects().length) return !1;
      const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
        i = t.closest("details:not([open])");
      if (!i) return e;
      if (i !== t) {
        const e = t.closest("summary");
        if (e && e.parentNode !== i) return !1;
        if (null === e) return !1;
      }
      return e;
    },
    l = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    c = t => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        const e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null;
      }
      return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null;
    },
    h = () => {},
    d = t => {
      t.offsetHeight;
    },
    u = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
    f = [],
    p = () => "rtl" === document.documentElement.dir,
    m = t => {
      var e;
      e = () => {
        const e = u();
        if (e) {
          const i = t.NAME,
            n = e.fn[i];
          e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface);
        }
      }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", () => {
        for (const t of f) t();
      }), f.push(e)) : e();
    },
    g = (t, e = [], i = t) => "function" == typeof t ? t(...e) : i,
    _ = (t, e, n = !0) => {
      if (!n) return void g(t);
      const o = (t => {
        if (!t) return 0;
        let {
          transitionDuration: e,
          transitionDelay: i
        } = window.getComputedStyle(t);
        const n = Number.parseFloat(e),
          s = Number.parseFloat(i);
        return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;
      })(e) + 5;
      let r = !1;
      const a = ({
        target: n
      }) => {
        n === e && (r = !0, e.removeEventListener(i, a), g(t));
      };
      e.addEventListener(i, a), setTimeout(() => {
        r || s(e);
      }, o);
    },
    b = (t, e, i, n) => {
      const s = t.length;
      let o = t.indexOf(e);
      return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))]);
    },
    v = /[^.]*(?=\..*)\.|.*/,
    y = /\..*/,
    w = /::\d+$/,
    A = {};
  let E = 1;
  const T = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    },
    C = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function O(t, e) {
    return e && `${e}::${E++}` || t.uidEvent || E++;
  }
  function x(t) {
    const e = O(t);
    return t.uidEvent = e, A[e] = A[e] || {}, A[e];
  }
  function k(t, e, i = null) {
    return Object.values(t).find(t => t.callable === e && t.delegationSelector === i);
  }
  function L(t, e, i) {
    const n = "string" == typeof e,
      s = n ? i : e || i;
    let o = I(t);
    return C.has(o) || (o = t), [n, s, o];
  }
  function S(t, e, i, n, s) {
    if ("string" != typeof e || !t) return;
    let [o, r, a] = L(e, i, n);
    if (e in T) {
      const t = t => function (e) {
        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);
      };
      r = t(r);
    }
    const l = x(t),
      c = l[a] || (l[a] = {}),
      h = k(c, r, o ? i : null);
    if (h) return void (h.oneOff = h.oneOff && s);
    const d = O(r, e.replace(v, "")),
      u = o ? function (t, e, i) {
        return function n(s) {
          const o = t.querySelectorAll(e);
          for (let {
            target: r
          } = s; r && r !== this; r = r.parentNode) for (const a of o) if (a === r) return P(s, {
            delegateTarget: r
          }), n.oneOff && N.off(t, s.type, e, i), i.apply(r, [s]);
        };
      }(t, i, r) : function (t, e) {
        return function i(n) {
          return P(n, {
            delegateTarget: t
          }), i.oneOff && N.off(t, n.type, e), e.apply(t, [n]);
        };
      }(t, r);
    u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);
  }
  function D(t, e, i, n, s) {
    const o = k(e[i], n, s);
    o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);
  }
  function $(t, e, i, n) {
    const s = e[i] || {};
    for (const [o, r] of Object.entries(s)) o.includes(n) && D(t, e, i, r.callable, r.delegationSelector);
  }
  function I(t) {
    return t = t.replace(y, ""), T[t] || t;
  }
  const N = {
    on(t, e, i, n) {
      S(t, e, i, n, !1);
    },
    one(t, e, i, n) {
      S(t, e, i, n, !0);
    },
    off(t, e, i, n) {
      if ("string" != typeof e || !t) return;
      const [s, o, r] = L(e, i, n),
        a = r !== e,
        l = x(t),
        c = l[r] || {},
        h = e.startsWith(".");
      if (void 0 === o) {
        if (h) for (const i of Object.keys(l)) $(t, l, i, e.slice(1));
        for (const [i, n] of Object.entries(c)) {
          const s = i.replace(w, "");
          a && !e.includes(s) || D(t, l, r, n.callable, n.delegationSelector);
        }
      } else {
        if (!Object.keys(c).length) return;
        D(t, l, r, o, s ? i : null);
      }
    },
    trigger(t, e, i) {
      if ("string" != typeof e || !t) return null;
      const n = u();
      let s = null,
        o = !0,
        r = !0,
        a = !1;
      e !== I(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
      const l = P(new Event(e, {
        bubbles: o,
        cancelable: !0
      }), i);
      return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l;
    }
  };
  function P(t, e = {}) {
    for (const [i, n] of Object.entries(e)) try {
      t[i] = n;
    } catch (e) {
      Object.defineProperty(t, i, {
        configurable: !0,
        get: () => n
      });
    }
    return t;
  }
  function j(t) {
    if ("true" === t) return !0;
    if ("false" === t) return !1;
    if (t === Number(t).toString()) return Number(t);
    if ("" === t || "null" === t) return null;
    if ("string" != typeof t) return t;
    try {
      return JSON.parse(decodeURIComponent(t));
    } catch (e) {
      return t;
    }
  }
  function M(t) {
    return t.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`);
  }
  const F = {
    setDataAttribute(t, e, i) {
      t.setAttribute(`data-bs-${M(e)}`, i);
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${M(e)}`);
    },
    getDataAttributes(t) {
      if (!t) return {};
      const e = {},
        i = Object.keys(t.dataset).filter(t => t.startsWith("bs") && !t.startsWith("bsConfig"));
      for (const n of i) {
        let i = n.replace(/^bs/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = j(t.dataset[n]);
      }
      return e;
    },
    getDataAttribute: (t, e) => j(t.getAttribute(`data-bs-${M(e)}`))
  };
  class H {
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(t) {
      return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
    }
    _configAfterMerge(t) {
      return t;
    }
    _mergeConfigObj(t, e) {
      const i = o(e) ? F.getDataAttribute(e, "config") : {};
      return {
        ...this.constructor.Default,
        ...("object" == typeof i ? i : {}),
        ...(o(e) ? F.getDataAttributes(e) : {}),
        ...("object" == typeof t ? t : {})
      };
    }
    _typeCheckConfig(t, e = this.constructor.DefaultType) {
      for (const [n, s] of Object.entries(e)) {
        const e = t[n],
          r = o(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
        if (!new RegExp(s).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`);
      }
      var i;
    }
  }
  class W extends H {
    constructor(t, i) {
      super(), (t = r(t)) && (this._element = t, this._config = this._getConfig(i), e.set(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      e.remove(this._element, this.constructor.DATA_KEY), N.off(this._element, this.constructor.EVENT_KEY);
      for (const t of Object.getOwnPropertyNames(this)) this[t] = null;
    }
    _queueCallback(t, e, i = !0) {
      _(t, e, i);
    }
    _getConfig(t) {
      return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
    }
    static getInstance(t) {
      return e.get(r(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, "object" == typeof e ? e : null);
    }
    static get VERSION() {
      return "5.3.3";
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(t) {
      return `${t}${this.EVENT_KEY}`;
    }
  }
  const B = t => {
      let e = t.getAttribute("data-bs-target");
      if (!e || "#" === e) {
        let i = t.getAttribute("href");
        if (!i || !i.includes("#") && !i.startsWith(".")) return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null;
      }
      return e ? e.split(",").map(t => n(t)).join(",") : null;
    },
    z = {
      find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
      parents(t, e) {
        const i = [];
        let n = t.parentNode.closest(e);
        for (; n;) i.push(n), n = n.parentNode.closest(e);
        return i;
      },
      prev(t, e) {
        let i = t.previousElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.previousElementSibling;
        }
        return [];
      },
      next(t, e) {
        let i = t.nextElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.nextElementSibling;
        }
        return [];
      },
      focusableChildren(t) {
        const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(t => `${t}:not([tabindex^="-"])`).join(",");
        return this.find(e, t).filter(t => !l(t) && a(t));
      },
      getSelectorFromElement(t) {
        const e = B(t);
        return e && z.findOne(e) ? e : null;
      },
      getElementFromSelector(t) {
        const e = B(t);
        return e ? z.findOne(e) : null;
      },
      getMultipleElementsFromSelector(t) {
        const e = B(t);
        return e ? z.find(e) : [];
      }
    },
    R = (t, e = "hide") => {
      const i = `click.dismiss${t.EVENT_KEY}`,
        n = t.NAME;
      N.on(document, i, `[data-bs-dismiss="${n}"]`, function (i) {
        if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), l(this)) return;
        const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
        t.getOrCreateInstance(s)[e]();
      });
    },
    q = ".bs.alert",
    V = `close${q}`,
    K = `closed${q}`;
  class Q extends W {
    static get NAME() {
      return "alert";
    }
    close() {
      if (N.trigger(this._element, V).defaultPrevented) return;
      this._element.classList.remove("show");
      const t = this._element.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(), this._element, t);
    }
    _destroyElement() {
      this._element.remove(), N.trigger(this._element, K), this.dispose();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Q.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  R(Q, "close"), m(Q);
  const X = '[data-bs-toggle="button"]';
  class Y extends W {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Y.getOrCreateInstance(this);
        "toggle" === t && e[t]();
      });
    }
  }
  N.on(document, "click.bs.button.data-api", X, t => {
    t.preventDefault();
    const e = t.target.closest(X);
    Y.getOrCreateInstance(e).toggle();
  }), m(Y);
  const U = ".bs.swipe",
    G = `touchstart${U}`,
    J = `touchmove${U}`,
    Z = `touchend${U}`,
    tt = `pointerdown${U}`,
    et = `pointerup${U}`,
    it = {
      endCallback: null,
      leftCallback: null,
      rightCallback: null
    },
    nt = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)"
    };
  class st extends H {
    constructor(t, e) {
      super(), this._element = t, t && st.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
    }
    static get Default() {
      return it;
    }
    static get DefaultType() {
      return nt;
    }
    static get NAME() {
      return "swipe";
    }
    dispose() {
      N.off(this._element, U);
    }
    _start(t) {
      this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX;
    }
    _end(t) {
      this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback);
    }
    _move(t) {
      this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const t = Math.abs(this._deltaX);
      if (t <= 40) return;
      const e = t / this._deltaX;
      this._deltaX = 0, e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      this._supportPointerEvents ? (N.on(this._element, tt, t => this._start(t)), N.on(this._element, et, t => this._end(t)), this._element.classList.add("pointer-event")) : (N.on(this._element, G, t => this._start(t)), N.on(this._element, J, t => this._move(t)), N.on(this._element, Z, t => this._end(t)));
    }
    _eventIsPointerPenTouch(t) {
      return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType);
    }
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  }
  const ot = ".bs.carousel",
    rt = ".data-api",
    at = "next",
    lt = "prev",
    ct = "left",
    ht = "right",
    dt = `slide${ot}`,
    ut = `slid${ot}`,
    ft = `keydown${ot}`,
    pt = `mouseenter${ot}`,
    mt = `mouseleave${ot}`,
    gt = `dragstart${ot}`,
    _t = `load${ot}${rt}`,
    bt = `click${ot}${rt}`,
    vt = "carousel",
    yt = "active",
    wt = ".active",
    At = ".carousel-item",
    Et = wt + At,
    Tt = {
      ArrowLeft: ht,
      ArrowRight: ct
    },
    Ct = {
      interval: 5e3,
      keyboard: !0,
      pause: "hover",
      ride: !1,
      touch: !0,
      wrap: !0
    },
    Ot = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean"
    };
  class xt extends W {
    constructor(t, e) {
      super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === vt && this.cycle();
    }
    static get Default() {
      return Ct;
    }
    static get DefaultType() {
      return Ot;
    }
    static get NAME() {
      return "carousel";
    }
    next() {
      this._slide(at);
    }
    nextWhenVisible() {
      !document.hidden && a(this._element) && this.next();
    }
    prev() {
      this._slide(lt);
    }
    pause() {
      this._isSliding && s(this._element), this._clearInterval();
    }
    cycle() {
      this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      this._config.ride && (this._isSliding ? N.one(this._element, ut, () => this.cycle()) : this.cycle());
    }
    to(t) {
      const e = this._getItems();
      if (t > e.length - 1 || t < 0) return;
      if (this._isSliding) return void N.one(this._element, ut, () => this.to(t));
      const i = this._getItemIndex(this._getActive());
      if (i === t) return;
      const n = t > i ? at : lt;
      this._slide(n, e[t]);
    }
    dispose() {
      this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
    }
    _configAfterMerge(t) {
      return t.defaultInterval = t.interval, t;
    }
    _addEventListeners() {
      this._config.keyboard && N.on(this._element, ft, t => this._keydown(t)), "hover" === this._config.pause && (N.on(this._element, pt, () => this.pause()), N.on(this._element, mt, () => this._maybeEnableCycle())), this._config.touch && st.isSupported() && this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      for (const t of z.find(".carousel-item img", this._element)) N.on(t, gt, t => t.preventDefault());
      const t = {
        leftCallback: () => this._slide(this._directionToOrder(ct)),
        rightCallback: () => this._slide(this._directionToOrder(ht)),
        endCallback: () => {
          "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
        }
      };
      this._swipeHelper = new st(this._element, t);
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      const e = Tt[t.key];
      e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
    }
    _getItemIndex(t) {
      return this._getItems().indexOf(t);
    }
    _setActiveIndicatorElement(t) {
      if (!this._indicatorsElement) return;
      const e = z.findOne(wt, this._indicatorsElement);
      e.classList.remove(yt), e.removeAttribute("aria-current");
      const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
      i && (i.classList.add(yt), i.setAttribute("aria-current", "true"));
    }
    _updateInterval() {
      const t = this._activeElement || this._getActive();
      if (!t) return;
      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      this._config.interval = e || this._config.defaultInterval;
    }
    _slide(t, e = null) {
      if (this._isSliding) return;
      const i = this._getActive(),
        n = t === at,
        s = e || b(this._getItems(), i, n, this._config.wrap);
      if (s === i) return;
      const o = this._getItemIndex(s),
        r = e => N.trigger(this._element, e, {
          relatedTarget: s,
          direction: this._orderToDirection(t),
          from: this._getItemIndex(i),
          to: o
        });
      if (r(dt).defaultPrevented) return;
      if (!i || !s) return;
      const a = Boolean(this._interval);
      this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
      const l = n ? "carousel-item-start" : "carousel-item-end",
        c = n ? "carousel-item-next" : "carousel-item-prev";
      s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback(() => {
        s.classList.remove(l, c), s.classList.add(yt), i.classList.remove(yt, c, l), this._isSliding = !1, r(ut);
      }, i, this._isAnimated()), a && this.cycle();
    }
    _isAnimated() {
      return this._element.classList.contains("slide");
    }
    _getActive() {
      return z.findOne(Et, this._element);
    }
    _getItems() {
      return z.find(At, this._element);
    }
    _clearInterval() {
      this._interval && (clearInterval(this._interval), this._interval = null);
    }
    _directionToOrder(t) {
      return p() ? t === ct ? lt : at : t === ct ? at : lt;
    }
    _orderToDirection(t) {
      return p() ? t === lt ? ct : ht : t === lt ? ht : ct;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = xt.getOrCreateInstance(this, t);
        if ("number" != typeof t) {
          if ("string" == typeof t) {
            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        } else e.to(t);
      });
    }
  }
  N.on(document, bt, "[data-bs-slide], [data-bs-slide-to]", function (t) {
    const e = z.getElementFromSelector(this);
    if (!e || !e.classList.contains(vt)) return;
    t.preventDefault();
    const i = xt.getOrCreateInstance(e),
      n = this.getAttribute("data-bs-slide-to");
    return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === F.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle());
  }), N.on(window, _t, () => {
    const t = z.find('[data-bs-ride="carousel"]');
    for (const e of t) xt.getOrCreateInstance(e);
  }), m(xt);
  const kt = ".bs.collapse",
    Lt = `show${kt}`,
    St = `shown${kt}`,
    Dt = `hide${kt}`,
    $t = `hidden${kt}`,
    It = `click${kt}.data-api`,
    Nt = "show",
    Pt = "collapse",
    jt = "collapsing",
    Mt = `:scope .${Pt} .${Pt}`,
    Ft = '[data-bs-toggle="collapse"]',
    Ht = {
      parent: null,
      toggle: !0
    },
    Wt = {
      parent: "(null|element)",
      toggle: "boolean"
    };
  class Bt extends W {
    constructor(t, e) {
      super(t, e), this._isTransitioning = !1, this._triggerArray = [];
      const i = z.find(Ft);
      for (const t of i) {
        const e = z.getSelectorFromElement(t),
          i = z.find(e).filter(t => t === this._element);
        null !== e && i.length && this._triggerArray.push(t);
      }
      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
    }
    static get Default() {
      return Ht;
    }
    static get DefaultType() {
      return Wt;
    }
    static get NAME() {
      return "collapse";
    }
    toggle() {
      this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (this._isTransitioning || this._isShown()) return;
      let t = [];
      if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(t => t !== this._element).map(t => Bt.getOrCreateInstance(t, {
        toggle: !1
      }))), t.length && t[0]._isTransitioning) return;
      if (N.trigger(this._element, Lt).defaultPrevented) return;
      for (const e of t) e.hide();
      const e = this._getDimension();
      this._element.classList.remove(Pt), this._element.classList.add(jt), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
      const i = `scroll${e[0].toUpperCase() + e.slice(1)}`;
      this._queueCallback(() => {
        this._isTransitioning = !1, this._element.classList.remove(jt), this._element.classList.add(Pt, Nt), this._element.style[e] = "", N.trigger(this._element, St);
      }, this._element, !0), this._element.style[e] = `${this._element[i]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) return;
      if (N.trigger(this._element, Dt).defaultPrevented) return;
      const t = this._getDimension();
      this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(jt), this._element.classList.remove(Pt, Nt);
      for (const t of this._triggerArray) {
        const e = z.getElementFromSelector(t);
        e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1);
      }
      this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(() => {
        this._isTransitioning = !1, this._element.classList.remove(jt), this._element.classList.add(Pt), N.trigger(this._element, $t);
      }, this._element, !0);
    }
    _isShown(t = this._element) {
      return t.classList.contains(Nt);
    }
    _configAfterMerge(t) {
      return t.toggle = Boolean(t.toggle), t.parent = r(t.parent), t;
    }
    _getDimension() {
      return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
    }
    _initializeChildren() {
      if (!this._config.parent) return;
      const t = this._getFirstLevelChildren(Ft);
      for (const e of t) {
        const t = z.getElementFromSelector(e);
        t && this._addAriaAndCollapsedClass([e], this._isShown(t));
      }
    }
    _getFirstLevelChildren(t) {
      const e = z.find(Mt, this._config.parent);
      return z.find(t, this._config.parent).filter(t => !e.includes(t));
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t.length) for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e);
    }
    static jQueryInterface(t) {
      const e = {};
      return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each(function () {
        const i = Bt.getOrCreateInstance(this, e);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t]();
        }
      });
    }
  }
  N.on(document, It, Ft, function (t) {
    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
    for (const t of z.getMultipleElementsFromSelector(this)) Bt.getOrCreateInstance(t, {
      toggle: !1
    }).toggle();
  }), m(Bt);
  var zt = "top",
    Rt = "bottom",
    qt = "right",
    Vt = "left",
    Kt = "auto",
    Qt = [zt, Rt, qt, Vt],
    Xt = "start",
    Yt = "end",
    Ut = "clippingParents",
    Gt = "viewport",
    Jt = "popper",
    Zt = "reference",
    te = Qt.reduce(function (t, e) {
      return t.concat([e + "-" + Xt, e + "-" + Yt]);
    }, []),
    ee = [].concat(Qt, [Kt]).reduce(function (t, e) {
      return t.concat([e, e + "-" + Xt, e + "-" + Yt]);
    }, []),
    ie = "beforeRead",
    ne = "read",
    se = "afterRead",
    oe = "beforeMain",
    re = "main",
    ae = "afterMain",
    le = "beforeWrite",
    ce = "write",
    he = "afterWrite",
    de = [ie, ne, se, oe, re, ae, le, ce, he];
  function ue(t) {
    return t ? (t.nodeName || "").toLowerCase() : null;
  }
  function fe(t) {
    if (null == t) return window;
    if ("[object Window]" !== t.toString()) {
      var e = t.ownerDocument;
      return e && e.defaultView || window;
    }
    return t;
  }
  function pe(t) {
    return t instanceof fe(t).Element || t instanceof Element;
  }
  function me(t) {
    return t instanceof fe(t).HTMLElement || t instanceof HTMLElement;
  }
  function ge(t) {
    return "undefined" != typeof ShadowRoot && (t instanceof fe(t).ShadowRoot || t instanceof ShadowRoot);
  }
  const _e = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function (t) {
        var i = e.styles[t] || {},
          n = e.attributes[t] || {},
          s = e.elements[t];
        me(s) && ue(s) && (Object.assign(s.style, i), Object.keys(n).forEach(function (t) {
          var e = n[t];
          !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e);
        }));
      });
    },
    effect: function (t) {
      var e = t.state,
        i = {
          popper: {
            position: e.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
      return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function () {
        Object.keys(e.elements).forEach(function (t) {
          var n = e.elements[t],
            s = e.attributes[t] || {},
            o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function (t, e) {
              return t[e] = "", t;
            }, {});
          me(n) && ue(n) && (Object.assign(n.style, o), Object.keys(s).forEach(function (t) {
            n.removeAttribute(t);
          }));
        });
      };
    },
    requires: ["computeStyles"]
  };
  function be(t) {
    return t.split("-")[0];
  }
  var ve = Math.max,
    ye = Math.min,
    we = Math.round;
  function Ae() {
    var t = navigator.userAgentData;
    return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map(function (t) {
      return t.brand + "/" + t.version;
    }).join(" ") : navigator.userAgent;
  }
  function Ee() {
    return !/^((?!chrome|android).)*safari/i.test(Ae());
  }
  function Te(t, e, i) {
    void 0 === e && (e = !1), void 0 === i && (i = !1);
    var n = t.getBoundingClientRect(),
      s = 1,
      o = 1;
    e && me(t) && (s = t.offsetWidth > 0 && we(n.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && we(n.height) / t.offsetHeight || 1);
    var r = (pe(t) ? fe(t) : window).visualViewport,
      a = !Ee() && i,
      l = (n.left + (a && r ? r.offsetLeft : 0)) / s,
      c = (n.top + (a && r ? r.offsetTop : 0)) / o,
      h = n.width / s,
      d = n.height / o;
    return {
      width: h,
      height: d,
      top: c,
      right: l + h,
      bottom: c + d,
      left: l,
      x: l,
      y: c
    };
  }
  function Ce(t) {
    var e = Te(t),
      i = t.offsetWidth,
      n = t.offsetHeight;
    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: i,
      height: n
    };
  }
  function Oe(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (i && ge(i)) {
      var n = e;
      do {
        if (n && t.isSameNode(n)) return !0;
        n = n.parentNode || n.host;
      } while (n);
    }
    return !1;
  }
  function xe(t) {
    return fe(t).getComputedStyle(t);
  }
  function ke(t) {
    return ["table", "td", "th"].indexOf(ue(t)) >= 0;
  }
  function Le(t) {
    return ((pe(t) ? t.ownerDocument : t.document) || window.document).documentElement;
  }
  function Se(t) {
    return "html" === ue(t) ? t : t.assignedSlot || t.parentNode || (ge(t) ? t.host : null) || Le(t);
  }
  function De(t) {
    return me(t) && "fixed" !== xe(t).position ? t.offsetParent : null;
  }
  function $e(t) {
    for (var e = fe(t), i = De(t); i && ke(i) && "static" === xe(i).position;) i = De(i);
    return i && ("html" === ue(i) || "body" === ue(i) && "static" === xe(i).position) ? e : i || function (t) {
      var e = /firefox/i.test(Ae());
      if (/Trident/i.test(Ae()) && me(t) && "fixed" === xe(t).position) return null;
      var i = Se(t);
      for (ge(i) && (i = i.host); me(i) && ["html", "body"].indexOf(ue(i)) < 0;) {
        var n = xe(i);
        if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
        i = i.parentNode;
      }
      return null;
    }(t) || e;
  }
  function Ie(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
  }
  function Ne(t, e, i) {
    return ve(t, ye(e, i));
  }
  function Pe(t) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, t);
  }
  function je(t, e) {
    return e.reduce(function (e, i) {
      return e[i] = t, e;
    }, {});
  }
  const Me = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e,
        i = t.state,
        n = t.name,
        s = t.options,
        o = i.elements.arrow,
        r = i.modifiersData.popperOffsets,
        a = be(i.placement),
        l = Ie(a),
        c = [Vt, qt].indexOf(a) >= 0 ? "height" : "width";
      if (o && r) {
        var h = function (t, e) {
            return Pe("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {
              placement: e.placement
            })) : t) ? t : je(t, Qt));
          }(s.padding, i),
          d = Ce(o),
          u = "y" === l ? zt : Vt,
          f = "y" === l ? Rt : qt,
          p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],
          m = r[l] - i.rects.reference[l],
          g = $e(o),
          _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,
          b = p / 2 - m / 2,
          v = h[u],
          y = _ - d[c] - h[f],
          w = _ / 2 - d[c] / 2 + b,
          A = Ne(v, w, y),
          E = l;
        i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e);
      }
    },
    effect: function (t) {
      var e = t.state,
        i = t.options.element,
        n = void 0 === i ? "[data-popper-arrow]" : i;
      null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && Oe(e.elements.popper, n) && (e.elements.arrow = n);
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function Fe(t) {
    return t.split("-")[1];
  }
  var He = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function We(t) {
    var e,
      i = t.popper,
      n = t.popperRect,
      s = t.placement,
      o = t.variation,
      r = t.offsets,
      a = t.position,
      l = t.gpuAcceleration,
      c = t.adaptive,
      h = t.roundOffsets,
      d = t.isFixed,
      u = r.x,
      f = void 0 === u ? 0 : u,
      p = r.y,
      m = void 0 === p ? 0 : p,
      g = "function" == typeof h ? h({
        x: f,
        y: m
      }) : {
        x: f,
        y: m
      };
    f = g.x, m = g.y;
    var _ = r.hasOwnProperty("x"),
      b = r.hasOwnProperty("y"),
      v = Vt,
      y = zt,
      w = window;
    if (c) {
      var A = $e(i),
        E = "clientHeight",
        T = "clientWidth";
      A === fe(i) && "static" !== xe(A = Le(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === zt || (s === Vt || s === qt) && o === Yt) && (y = Rt, m -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, m *= l ? 1 : -1), s !== Vt && (s !== zt && s !== Rt || o !== Yt) || (v = qt, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1);
    }
    var C,
      O = Object.assign({
        position: a
      }, c && He),
      x = !0 === h ? function (t, e) {
        var i = t.x,
          n = t.y,
          s = e.devicePixelRatio || 1;
        return {
          x: we(i * s) / s || 0,
          y: we(n * s) / s || 0
        };
      }({
        x: f,
        y: m
      }, fe(i)) : {
        x: f,
        y: m
      };
    return f = x.x, m = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? m + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e));
  }
  const Be = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = i.gpuAcceleration,
        s = void 0 === n || n,
        o = i.adaptive,
        r = void 0 === o || o,
        a = i.roundOffsets,
        l = void 0 === a || a,
        c = {
          placement: be(e.placement),
          variation: Fe(e.placement),
          popper: e.elements.popper,
          popperRect: e.rects.popper,
          gpuAcceleration: s,
          isFixed: "fixed" === e.options.strategy
        };
      null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, We(Object.assign({}, c, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: r,
        roundOffsets: l
      })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, We(Object.assign({}, c, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    },
    data: {}
  };
  var ze = {
    passive: !0
  };
  const Re = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (t) {
      var e = t.state,
        i = t.instance,
        n = t.options,
        s = n.scroll,
        o = void 0 === s || s,
        r = n.resize,
        a = void 0 === r || r,
        l = fe(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return o && c.forEach(function (t) {
        t.addEventListener("scroll", i.update, ze);
      }), a && l.addEventListener("resize", i.update, ze), function () {
        o && c.forEach(function (t) {
          t.removeEventListener("scroll", i.update, ze);
        }), a && l.removeEventListener("resize", i.update, ze);
      };
    },
    data: {}
  };
  var qe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Ve(t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return qe[t];
    });
  }
  var Ke = {
    start: "end",
    end: "start"
  };
  function Qe(t) {
    return t.replace(/start|end/g, function (t) {
      return Ke[t];
    });
  }
  function Xe(t) {
    var e = fe(t);
    return {
      scrollLeft: e.pageXOffset,
      scrollTop: e.pageYOffset
    };
  }
  function Ye(t) {
    return Te(Le(t)).left + Xe(t).scrollLeft;
  }
  function Ue(t) {
    var e = xe(t),
      i = e.overflow,
      n = e.overflowX,
      s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + s + n);
  }
  function Ge(t) {
    return ["html", "body", "#document"].indexOf(ue(t)) >= 0 ? t.ownerDocument.body : me(t) && Ue(t) ? t : Ge(Se(t));
  }
  function Je(t, e) {
    var i;
    void 0 === e && (e = []);
    var n = Ge(t),
      s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),
      o = fe(n),
      r = s ? [o].concat(o.visualViewport || [], Ue(n) ? n : []) : n,
      a = e.concat(r);
    return s ? a : a.concat(Je(Se(r)));
  }
  function Ze(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    });
  }
  function ti(t, e, i) {
    return e === Gt ? Ze(function (t, e) {
      var i = fe(t),
        n = Le(t),
        s = i.visualViewport,
        o = n.clientWidth,
        r = n.clientHeight,
        a = 0,
        l = 0;
      if (s) {
        o = s.width, r = s.height;
        var c = Ee();
        (c || !c && "fixed" === e) && (a = s.offsetLeft, l = s.offsetTop);
      }
      return {
        width: o,
        height: r,
        x: a + Ye(t),
        y: l
      };
    }(t, i)) : pe(e) ? function (t, e) {
      var i = Te(t, !1, "fixed" === e);
      return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i;
    }(e, i) : Ze(function (t) {
      var e,
        i = Le(t),
        n = Xe(t),
        s = null == (e = t.ownerDocument) ? void 0 : e.body,
        o = ve(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),
        r = ve(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),
        a = -n.scrollLeft + Ye(t),
        l = -n.scrollTop;
      return "rtl" === xe(s || i).direction && (a += ve(i.clientWidth, s ? s.clientWidth : 0) - o), {
        width: o,
        height: r,
        x: a,
        y: l
      };
    }(Le(t)));
  }
  function ei(t) {
    var e,
      i = t.reference,
      n = t.element,
      s = t.placement,
      o = s ? be(s) : null,
      r = s ? Fe(s) : null,
      a = i.x + i.width / 2 - n.width / 2,
      l = i.y + i.height / 2 - n.height / 2;
    switch (o) {
      case zt:
        e = {
          x: a,
          y: i.y - n.height
        };
        break;
      case Rt:
        e = {
          x: a,
          y: i.y + i.height
        };
        break;
      case qt:
        e = {
          x: i.x + i.width,
          y: l
        };
        break;
      case Vt:
        e = {
          x: i.x - n.width,
          y: l
        };
        break;
      default:
        e = {
          x: i.x,
          y: i.y
        };
    }
    var c = o ? Ie(o) : null;
    if (null != c) {
      var h = "y" === c ? "height" : "width";
      switch (r) {
        case Xt:
          e[c] = e[c] - (i[h] / 2 - n[h] / 2);
          break;
        case Yt:
          e[c] = e[c] + (i[h] / 2 - n[h] / 2);
      }
    }
    return e;
  }
  function ii(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = void 0 === n ? t.placement : n,
      o = i.strategy,
      r = void 0 === o ? t.strategy : o,
      a = i.boundary,
      l = void 0 === a ? Ut : a,
      c = i.rootBoundary,
      h = void 0 === c ? Gt : c,
      d = i.elementContext,
      u = void 0 === d ? Jt : d,
      f = i.altBoundary,
      p = void 0 !== f && f,
      m = i.padding,
      g = void 0 === m ? 0 : m,
      _ = Pe("number" != typeof g ? g : je(g, Qt)),
      b = u === Jt ? Zt : Jt,
      v = t.rects.popper,
      y = t.elements[p ? b : u],
      w = function (t, e, i, n) {
        var s = "clippingParents" === e ? function (t) {
            var e = Je(Se(t)),
              i = ["absolute", "fixed"].indexOf(xe(t).position) >= 0 && me(t) ? $e(t) : t;
            return pe(i) ? e.filter(function (t) {
              return pe(t) && Oe(t, i) && "body" !== ue(t);
            }) : [];
          }(t) : [].concat(e),
          o = [].concat(s, [i]),
          r = o[0],
          a = o.reduce(function (e, i) {
            var s = ti(t, i, n);
            return e.top = ve(s.top, e.top), e.right = ye(s.right, e.right), e.bottom = ye(s.bottom, e.bottom), e.left = ve(s.left, e.left), e;
          }, ti(t, r, n));
        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
      }(pe(y) ? y : y.contextElement || Le(t.elements.popper), l, h, r),
      A = Te(t.elements.reference),
      E = ei({
        reference: A,
        element: v,
        strategy: "absolute",
        placement: s
      }),
      T = Ze(Object.assign({}, v, E)),
      C = u === Jt ? T : A,
      O = {
        top: w.top - C.top + _.top,
        bottom: C.bottom - w.bottom + _.bottom,
        left: w.left - C.left + _.left,
        right: C.right - w.right + _.right
      },
      x = t.modifiersData.offset;
    if (u === Jt && x) {
      var k = x[s];
      Object.keys(O).forEach(function (t) {
        var e = [qt, Rt].indexOf(t) >= 0 ? 1 : -1,
          i = [zt, Rt].indexOf(t) >= 0 ? "y" : "x";
        O[t] += k[i] * e;
      });
    }
    return O;
  }
  function ni(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = i.boundary,
      o = i.rootBoundary,
      r = i.padding,
      a = i.flipVariations,
      l = i.allowedAutoPlacements,
      c = void 0 === l ? ee : l,
      h = Fe(n),
      d = h ? a ? te : te.filter(function (t) {
        return Fe(t) === h;
      }) : Qt,
      u = d.filter(function (t) {
        return c.indexOf(t) >= 0;
      });
    0 === u.length && (u = d);
    var f = u.reduce(function (e, i) {
      return e[i] = ii(t, {
        placement: i,
        boundary: s,
        rootBoundary: o,
        padding: r
      })[be(i)], e;
    }, {});
    return Object.keys(f).sort(function (t, e) {
      return f[t] - f[e];
    });
  }
  const si = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = t.name;
      if (!e.modifiersData[n]._skip) {
        for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = be(g), b = l || (_ !== g && p ? function (t) {
            if (be(t) === Kt) return [];
            var e = Ve(t);
            return [Qe(t), e, Qe(e)];
          }(g) : [Ve(g)]), v = [g].concat(b).reduce(function (t, i) {
            return t.concat(be(i) === Kt ? ni(e, {
              placement: i,
              boundary: h,
              rootBoundary: d,
              padding: c,
              flipVariations: p,
              allowedAutoPlacements: m
            }) : i);
          }, []), y = e.rects.reference, w = e.rects.popper, A = new Map(), E = !0, T = v[0], C = 0; C < v.length; C++) {
          var O = v[C],
            x = be(O),
            k = Fe(O) === Xt,
            L = [zt, Rt].indexOf(x) >= 0,
            S = L ? "width" : "height",
            D = ii(e, {
              placement: O,
              boundary: h,
              rootBoundary: d,
              altBoundary: u,
              padding: c
            }),
            $ = L ? k ? qt : Vt : k ? Rt : zt;
          y[S] > w[S] && ($ = Ve($));
          var I = Ve($),
            N = [];
          if (o && N.push(D[x] <= 0), a && N.push(D[$] <= 0, D[I] <= 0), N.every(function (t) {
            return t;
          })) {
            T = O, E = !1;
            break;
          }
          A.set(O, N);
        }
        if (E) for (var P = function (t) {
            var e = v.find(function (e) {
              var i = A.get(e);
              if (i) return i.slice(0, t).every(function (t) {
                return t;
              });
            });
            if (e) return T = e, "break";
          }, j = p ? 3 : 1; j > 0 && "break" !== P(j); j--);
        e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };
  function oi(t, e, i) {
    return void 0 === i && (i = {
      x: 0,
      y: 0
    }), {
      top: t.top - e.height - i.y,
      right: t.right - e.width + i.x,
      bottom: t.bottom - e.height + i.y,
      left: t.left - e.width - i.x
    };
  }
  function ri(t) {
    return [zt, qt, Rt, Vt].some(function (e) {
      return t[e] >= 0;
    });
  }
  const ai = {
      name: "hide",
      enabled: !0,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: function (t) {
        var e = t.state,
          i = t.name,
          n = e.rects.reference,
          s = e.rects.popper,
          o = e.modifiersData.preventOverflow,
          r = ii(e, {
            elementContext: "reference"
          }),
          a = ii(e, {
            altBoundary: !0
          }),
          l = oi(r, n),
          c = oi(a, s, o),
          h = ri(l),
          d = ri(c);
        e.modifiersData[i] = {
          referenceClippingOffsets: l,
          popperEscapeOffsets: c,
          isReferenceHidden: h,
          hasPopperEscaped: d
        }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
          "data-popper-reference-hidden": h,
          "data-popper-escaped": d
        });
      }
    },
    li = {
      name: "offset",
      enabled: !0,
      phase: "main",
      requires: ["popperOffsets"],
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.offset,
          o = void 0 === s ? [0, 0] : s,
          r = ee.reduce(function (t, i) {
            return t[i] = function (t, e, i) {
              var n = be(t),
                s = [Vt, zt].indexOf(n) >= 0 ? -1 : 1,
                o = "function" == typeof i ? i(Object.assign({}, e, {
                  placement: t
                })) : i,
                r = o[0],
                a = o[1];
              return r = r || 0, a = (a || 0) * s, [Vt, qt].indexOf(n) >= 0 ? {
                x: a,
                y: r
              } : {
                x: r,
                y: a
              };
            }(i, e.rects, o), t;
          }, {}),
          a = r[e.placement],
          l = a.x,
          c = a.y;
        null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r;
      }
    },
    ci = {
      name: "popperOffsets",
      enabled: !0,
      phase: "read",
      fn: function (t) {
        var e = t.state,
          i = t.name;
        e.modifiersData[i] = ei({
          reference: e.rects.reference,
          element: e.rects.popper,
          strategy: "absolute",
          placement: e.placement
        });
      },
      data: {}
    },
    hi = {
      name: "preventOverflow",
      enabled: !0,
      phase: "main",
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.mainAxis,
          o = void 0 === s || s,
          r = i.altAxis,
          a = void 0 !== r && r,
          l = i.boundary,
          c = i.rootBoundary,
          h = i.altBoundary,
          d = i.padding,
          u = i.tether,
          f = void 0 === u || u,
          p = i.tetherOffset,
          m = void 0 === p ? 0 : p,
          g = ii(e, {
            boundary: l,
            rootBoundary: c,
            padding: d,
            altBoundary: h
          }),
          _ = be(e.placement),
          b = Fe(e.placement),
          v = !b,
          y = Ie(_),
          w = "x" === y ? "y" : "x",
          A = e.modifiersData.popperOffsets,
          E = e.rects.reference,
          T = e.rects.popper,
          C = "function" == typeof m ? m(Object.assign({}, e.rects, {
            placement: e.placement
          })) : m,
          O = "number" == typeof C ? {
            mainAxis: C,
            altAxis: C
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, C),
          x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
          k = {
            x: 0,
            y: 0
          };
        if (A) {
          if (o) {
            var L,
              S = "y" === y ? zt : Vt,
              D = "y" === y ? Rt : qt,
              $ = "y" === y ? "height" : "width",
              I = A[y],
              N = I + g[S],
              P = I - g[D],
              j = f ? -T[$] / 2 : 0,
              M = b === Xt ? E[$] : T[$],
              F = b === Xt ? -T[$] : -E[$],
              H = e.elements.arrow,
              W = f && H ? Ce(H) : {
                width: 0,
                height: 0
              },
              B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              },
              z = B[S],
              R = B[D],
              q = Ne(0, E[$], W[$]),
              V = v ? E[$] / 2 - j - q - z - O.mainAxis : M - q - z - O.mainAxis,
              K = v ? -E[$] / 2 + j + q + R + O.mainAxis : F + q + R + O.mainAxis,
              Q = e.elements.arrow && $e(e.elements.arrow),
              X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0,
              Y = null != (L = null == x ? void 0 : x[y]) ? L : 0,
              U = I + K - Y,
              G = Ne(f ? ye(N, I + V - Y - X) : N, I, f ? ve(P, U) : P);
            A[y] = G, k[y] = G - I;
          }
          if (a) {
            var J,
              Z = "x" === y ? zt : Vt,
              tt = "x" === y ? Rt : qt,
              et = A[w],
              it = "y" === w ? "height" : "width",
              nt = et + g[Z],
              st = et - g[tt],
              ot = -1 !== [zt, Vt].indexOf(_),
              rt = null != (J = null == x ? void 0 : x[w]) ? J : 0,
              at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis,
              lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st,
              ct = f && ot ? function (t, e, i) {
                var n = Ne(t, e, i);
                return n > i ? i : n;
              }(at, et, lt) : Ne(f ? at : nt, et, f ? lt : st);
            A[w] = ct, k[w] = ct - et;
          }
          e.modifiersData[n] = k;
        }
      },
      requiresIfExists: ["offset"]
    };
  function di(t, e, i) {
    void 0 === i && (i = !1);
    var n,
      s,
      o = me(e),
      r = me(e) && function (t) {
        var e = t.getBoundingClientRect(),
          i = we(e.width) / t.offsetWidth || 1,
          n = we(e.height) / t.offsetHeight || 1;
        return 1 !== i || 1 !== n;
      }(e),
      a = Le(e),
      l = Te(t, r, i),
      c = {
        scrollLeft: 0,
        scrollTop: 0
      },
      h = {
        x: 0,
        y: 0
      };
    return (o || !o && !i) && (("body" !== ue(e) || Ue(a)) && (c = (n = e) !== fe(n) && me(n) ? {
      scrollLeft: (s = n).scrollLeft,
      scrollTop: s.scrollTop
    } : Xe(n)), me(e) ? ((h = Te(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = Ye(a))), {
      x: l.left + c.scrollLeft - h.x,
      y: l.top + c.scrollTop - h.y,
      width: l.width,
      height: l.height
    };
  }
  function ui(t) {
    var e = new Map(),
      i = new Set(),
      n = [];
    function s(t) {
      i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) {
        if (!i.has(t)) {
          var n = e.get(t);
          n && s(n);
        }
      }), n.push(t);
    }
    return t.forEach(function (t) {
      e.set(t.name, t);
    }), t.forEach(function (t) {
      i.has(t.name) || s(t);
    }), n;
  }
  var fi = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function pi() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    return !e.some(function (t) {
      return !(t && "function" == typeof t.getBoundingClientRect);
    });
  }
  function mi(t) {
    void 0 === t && (t = {});
    var e = t,
      i = e.defaultModifiers,
      n = void 0 === i ? [] : i,
      s = e.defaultOptions,
      o = void 0 === s ? fi : s;
    return function (t, e, i) {
      void 0 === i && (i = o);
      var s,
        r,
        a = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, fi, o),
          modifiersData: {},
          elements: {
            reference: t,
            popper: e
          },
          attributes: {},
          styles: {}
        },
        l = [],
        c = !1,
        h = {
          state: a,
          setOptions: function (i) {
            var s = "function" == typeof i ? i(a.options) : i;
            d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
              reference: pe(t) ? Je(t) : t.contextElement ? Je(t.contextElement) : [],
              popper: Je(e)
            };
            var r,
              c,
              u = function (t) {
                var e = ui(t);
                return de.reduce(function (t, i) {
                  return t.concat(e.filter(function (t) {
                    return t.phase === i;
                  }));
                }, []);
              }((r = [].concat(n, a.options.modifiers), c = r.reduce(function (t, e) {
                var i = t[e.name];
                return t[e.name] = i ? Object.assign({}, i, e, {
                  options: Object.assign({}, i.options, e.options),
                  data: Object.assign({}, i.data, e.data)
                }) : e, t;
              }, {}), Object.keys(c).map(function (t) {
                return c[t];
              })));
            return a.orderedModifiers = u.filter(function (t) {
              return t.enabled;
            }), a.orderedModifiers.forEach(function (t) {
              var e = t.name,
                i = t.options,
                n = void 0 === i ? {} : i,
                s = t.effect;
              if ("function" == typeof s) {
                var o = s({
                  state: a,
                  name: e,
                  instance: h,
                  options: n
                });
                l.push(o || function () {});
              }
            }), h.update();
          },
          forceUpdate: function () {
            if (!c) {
              var t = a.elements,
                e = t.reference,
                i = t.popper;
              if (pi(e, i)) {
                a.rects = {
                  reference: di(e, $e(i), "fixed" === a.options.strategy),
                  popper: Ce(i)
                }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (t) {
                  return a.modifiersData[t.name] = Object.assign({}, t.data);
                });
                for (var n = 0; n < a.orderedModifiers.length; n++) if (!0 !== a.reset) {
                  var s = a.orderedModifiers[n],
                    o = s.fn,
                    r = s.options,
                    l = void 0 === r ? {} : r,
                    d = s.name;
                  "function" == typeof o && (a = o({
                    state: a,
                    options: l,
                    name: d,
                    instance: h
                  }) || a);
                } else a.reset = !1, n = -1;
              }
            }
          },
          update: (s = function () {
            return new Promise(function (t) {
              h.forceUpdate(), t(a);
            });
          }, function () {
            return r || (r = new Promise(function (t) {
              Promise.resolve().then(function () {
                r = void 0, t(s());
              });
            })), r;
          }),
          destroy: function () {
            d(), c = !0;
          }
        };
      if (!pi(t, e)) return h;
      function d() {
        l.forEach(function (t) {
          return t();
        }), l = [];
      }
      return h.setOptions(i).then(function (t) {
        !c && i.onFirstUpdate && i.onFirstUpdate(t);
      }), h;
    };
  }
  var gi = mi(),
    _i = mi({
      defaultModifiers: [Re, ci, Be, _e]
    }),
    bi = mi({
      defaultModifiers: [Re, ci, Be, _e, li, si, hi, Me, ai]
    });
  const vi = Object.freeze(Object.defineProperty({
      __proto__: null,
      afterMain: ae,
      afterRead: se,
      afterWrite: he,
      applyStyles: _e,
      arrow: Me,
      auto: Kt,
      basePlacements: Qt,
      beforeMain: oe,
      beforeRead: ie,
      beforeWrite: le,
      bottom: Rt,
      clippingParents: Ut,
      computeStyles: Be,
      createPopper: bi,
      createPopperBase: gi,
      createPopperLite: _i,
      detectOverflow: ii,
      end: Yt,
      eventListeners: Re,
      flip: si,
      hide: ai,
      left: Vt,
      main: re,
      modifierPhases: de,
      offset: li,
      placements: ee,
      popper: Jt,
      popperGenerator: mi,
      popperOffsets: ci,
      preventOverflow: hi,
      read: ne,
      reference: Zt,
      right: qt,
      start: Xt,
      top: zt,
      variationPlacements: te,
      viewport: Gt,
      write: ce
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    yi = "dropdown",
    wi = ".bs.dropdown",
    Ai = ".data-api",
    Ei = "ArrowUp",
    Ti = "ArrowDown",
    Ci = `hide${wi}`,
    Oi = `hidden${wi}`,
    xi = `show${wi}`,
    ki = `shown${wi}`,
    Li = `click${wi}${Ai}`,
    Si = `keydown${wi}${Ai}`,
    Di = `keyup${wi}${Ai}`,
    $i = "show",
    Ii = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    Ni = `${Ii}.${$i}`,
    Pi = ".dropdown-menu",
    ji = p() ? "top-end" : "top-start",
    Mi = p() ? "top-start" : "top-end",
    Fi = p() ? "bottom-end" : "bottom-start",
    Hi = p() ? "bottom-start" : "bottom-end",
    Wi = p() ? "left-start" : "right-start",
    Bi = p() ? "right-start" : "left-start",
    zi = {
      autoClose: !0,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle"
    },
    Ri = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)"
    };
  class qi extends W {
    constructor(t, e) {
      super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = z.next(this._element, Pi)[0] || z.prev(this._element, Pi)[0] || z.findOne(Pi, this._parent), this._inNavbar = this._detectNavbar();
    }
    static get Default() {
      return zi;
    }
    static get DefaultType() {
      return Ri;
    }
    static get NAME() {
      return yi;
    }
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (l(this._element) || this._isShown()) return;
      const t = {
        relatedTarget: this._element
      };
      if (!N.trigger(this._element, xi, t).defaultPrevented) {
        if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children)) N.on(t, "mouseover", h);
        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add($i), this._element.classList.add($i), N.trigger(this._element, ki, t);
      }
    }
    hide() {
      if (l(this._element) || !this._isShown()) return;
      const t = {
        relatedTarget: this._element
      };
      this._completeHide(t);
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
    }
    _completeHide(t) {
      if (!N.trigger(this._element, Ci, t).defaultPrevented) {
        if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) N.off(t, "mouseover", h);
        this._popper && this._popper.destroy(), this._menu.classList.remove($i), this._element.classList.remove($i), this._element.setAttribute("aria-expanded", "false"), F.removeDataAttribute(this._menu, "popper"), N.trigger(this._element, Oi, t);
      }
    }
    _getConfig(t) {
      if ("object" == typeof (t = super._getConfig(t)).reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${yi.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      return t;
    }
    _createPopper() {
      if (void 0 === vi) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      let t = this._element;
      "parent" === this._config.reference ? t = this._parent : o(this._config.reference) ? t = r(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
      const e = this._getPopperConfig();
      this._popper = bi(t, this._menu, e);
    }
    _isShown() {
      return this._menu.classList.contains($i);
    }
    _getPlacement() {
      const t = this._parent;
      if (t.classList.contains("dropend")) return Wi;
      if (t.classList.contains("dropstart")) return Bi;
      if (t.classList.contains("dropup-center")) return "top";
      if (t.classList.contains("dropdown-center")) return "bottom";
      const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? e ? Mi : ji : e ? Hi : Fi;
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar");
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;
    }
    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      return (this._inNavbar || "static" === this._config.display) && (F.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
        name: "applyStyles",
        enabled: !1
      }]), {
        ...t,
        ...g(this._config.popperConfig, [t])
      };
    }
    _selectMenuItem({
      key: t,
      target: e
    }) {
      const i = z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(t => a(t));
      i.length && b(i, e, t === Ti, !i.includes(e)).focus();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = qi.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
    static clearMenus(t) {
      if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
      const e = z.find(Ni);
      for (const i of e) {
        const e = qi.getInstance(i);
        if (!e || !1 === e._config.autoClose) continue;
        const n = t.composedPath(),
          s = n.includes(e._menu);
        if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
        if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
        const o = {
          relatedTarget: e._element
        };
        "click" === t.type && (o.clickEvent = t), e._completeHide(o);
      }
    }
    static dataApiKeydownHandler(t) {
      const e = /input|textarea/i.test(t.target.tagName),
        i = "Escape" === t.key,
        n = [Ei, Ti].includes(t.key);
      if (!n && !i) return;
      if (e && !i) return;
      t.preventDefault();
      const s = this.matches(Ii) ? this : z.prev(this, Ii)[0] || z.next(this, Ii)[0] || z.findOne(Ii, t.delegateTarget.parentNode),
        o = qi.getOrCreateInstance(s);
      if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
      o._isShown() && (t.stopPropagation(), o.hide(), s.focus());
    }
  }
  N.on(document, Si, Ii, qi.dataApiKeydownHandler), N.on(document, Si, Pi, qi.dataApiKeydownHandler), N.on(document, Li, qi.clearMenus), N.on(document, Di, qi.clearMenus), N.on(document, Li, Ii, function (t) {
    t.preventDefault(), qi.getOrCreateInstance(this).toggle();
  }), m(qi);
  const Vi = "backdrop",
    Ki = "show",
    Qi = `mousedown.bs.${Vi}`,
    Xi = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: !1,
      isVisible: !0,
      rootElement: "body"
    },
    Yi = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)"
    };
  class Ui extends H {
    constructor(t) {
      super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
    }
    static get Default() {
      return Xi;
    }
    static get DefaultType() {
      return Yi;
    }
    static get NAME() {
      return Vi;
    }
    show(t) {
      if (!this._config.isVisible) return void g(t);
      this._append();
      const e = this._getElement();
      this._config.isAnimated && d(e), e.classList.add(Ki), this._emulateAnimation(() => {
        g(t);
      });
    }
    hide(t) {
      this._config.isVisible ? (this._getElement().classList.remove(Ki), this._emulateAnimation(() => {
        this.dispose(), g(t);
      })) : g(t);
    }
    dispose() {
      this._isAppended && (N.off(this._element, Qi), this._element.remove(), this._isAppended = !1);
    }
    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t;
      }
      return this._element;
    }
    _configAfterMerge(t) {
      return t.rootElement = r(t.rootElement), t;
    }
    _append() {
      if (this._isAppended) return;
      const t = this._getElement();
      this._config.rootElement.append(t), N.on(t, Qi, () => {
        g(this._config.clickCallback);
      }), this._isAppended = !0;
    }
    _emulateAnimation(t) {
      _(t, this._getElement(), this._config.isAnimated);
    }
  }
  const Gi = ".bs.focustrap",
    Ji = `focusin${Gi}`,
    Zi = `keydown.tab${Gi}`,
    tn = "backward",
    en = {
      autofocus: !0,
      trapElement: null
    },
    nn = {
      autofocus: "boolean",
      trapElement: "element"
    };
  class sn extends H {
    constructor(t) {
      super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
    }
    static get Default() {
      return en;
    }
    static get DefaultType() {
      return nn;
    }
    static get NAME() {
      return "focustrap";
    }
    activate() {
      this._isActive || (this._config.autofocus && this._config.trapElement.focus(), N.off(document, Gi), N.on(document, Ji, t => this._handleFocusin(t)), N.on(document, Zi, t => this._handleKeydown(t)), this._isActive = !0);
    }
    deactivate() {
      this._isActive && (this._isActive = !1, N.off(document, Gi));
    }
    _handleFocusin(t) {
      const {
        trapElement: e
      } = this._config;
      if (t.target === document || t.target === e || e.contains(t.target)) return;
      const i = z.focusableChildren(e);
      0 === i.length ? e.focus() : this._lastTabNavDirection === tn ? i[i.length - 1].focus() : i[0].focus();
    }
    _handleKeydown(t) {
      "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? tn : "forward");
    }
  }
  const on = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    rn = ".sticky-top",
    an = "padding-right",
    ln = "margin-right";
  class cn {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      const t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }
    hide() {
      const t = this.getWidth();
      this._disableOverFlow(), this._setElementAttributes(this._element, an, e => e + t), this._setElementAttributes(on, an, e => e + t), this._setElementAttributes(rn, ln, e => e - t);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, an), this._resetElementAttributes(on, an), this._resetElementAttributes(rn, ln);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
    }
    _setElementAttributes(t, e, i) {
      const n = this.getWidth();
      this._applyManipulationCallback(t, t => {
        if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
        this._saveInitialAttribute(t, e);
        const s = window.getComputedStyle(t).getPropertyValue(e);
        t.style.setProperty(e, `${i(Number.parseFloat(s))}px`);
      });
    }
    _saveInitialAttribute(t, e) {
      const i = t.style.getPropertyValue(e);
      i && F.setDataAttribute(t, e, i);
    }
    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, t => {
        const i = F.getDataAttribute(t, e);
        null !== i ? (F.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e);
      });
    }
    _applyManipulationCallback(t, e) {
      if (o(t)) e(t);else for (const i of z.find(t, this._element)) e(i);
    }
  }
  const hn = ".bs.modal",
    dn = `hide${hn}`,
    un = `hidePrevented${hn}`,
    fn = `hidden${hn}`,
    pn = `show${hn}`,
    mn = `shown${hn}`,
    gn = `resize${hn}`,
    _n = `click.dismiss${hn}`,
    bn = `mousedown.dismiss${hn}`,
    vn = `keydown.dismiss${hn}`,
    yn = `click${hn}.data-api`,
    wn = "modal-open",
    An = "show",
    En = "modal-static",
    Tn = {
      backdrop: !0,
      focus: !0,
      keyboard: !0
    },
    Cn = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean"
    };
  class On extends W {
    constructor(t, e) {
      super(t, e), this._dialog = z.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new cn(), this._addEventListeners();
    }
    static get Default() {
      return Tn;
    }
    static get DefaultType() {
      return Cn;
    }
    static get NAME() {
      return "modal";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown || this._isTransitioning || N.trigger(this._element, pn, {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(wn), this._adjustDialog(), this._backdrop.show(() => this._showElement(t)));
    }
    hide() {
      this._isShown && !this._isTransitioning && (N.trigger(this._element, dn).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(An), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
    }
    dispose() {
      N.off(window, hn), N.off(this._dialog, hn), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new Ui({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new sn({
        trapElement: this._element
      });
    }
    _showElement(t) {
      document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
      const e = z.findOne(".modal-body", this._dialog);
      e && (e.scrollTop = 0), d(this._element), this._element.classList.add(An), this._queueCallback(() => {
        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, N.trigger(this._element, mn, {
          relatedTarget: t
        });
      }, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      N.on(this._element, vn, t => {
        "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
      }), N.on(window, gn, () => {
        this._isShown && !this._isTransitioning && this._adjustDialog();
      }), N.on(this._element, bn, t => {
        N.one(this._element, _n, e => {
          this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
        document.body.classList.remove(wn), this._resetAdjustments(), this._scrollBar.reset(), N.trigger(this._element, fn);
      });
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      if (N.trigger(this._element, un).defaultPrevented) return;
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._element.style.overflowY;
      "hidden" === e || this._element.classList.contains(En) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(En), this._queueCallback(() => {
        this._element.classList.remove(En), this._queueCallback(() => {
          this._element.style.overflowY = e;
        }, this._dialog);
      }, this._dialog), this._element.focus());
    }
    _adjustDialog() {
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._scrollBar.getWidth(),
        i = e > 0;
      if (i && !t) {
        const t = p() ? "paddingLeft" : "paddingRight";
        this._element.style[t] = `${e}px`;
      }
      if (!i && t) {
        const t = p() ? "paddingRight" : "paddingLeft";
        this._element.style[t] = `${e}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }
    static jQueryInterface(t, e) {
      return this.each(function () {
        const i = On.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }
  }
  N.on(document, yn, '[data-bs-toggle="modal"]', function (t) {
    const e = z.getElementFromSelector(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), N.one(e, pn, t => {
      t.defaultPrevented || N.one(e, fn, () => {
        a(this) && this.focus();
      });
    });
    const i = z.findOne(".modal.show");
    i && On.getInstance(i).hide(), On.getOrCreateInstance(e).toggle(this);
  }), R(On), m(On);
  const xn = ".bs.offcanvas",
    kn = ".data-api",
    Ln = `load${xn}${kn}`,
    Sn = "show",
    Dn = "showing",
    $n = "hiding",
    In = ".offcanvas.show",
    Nn = `show${xn}`,
    Pn = `shown${xn}`,
    jn = `hide${xn}`,
    Mn = `hidePrevented${xn}`,
    Fn = `hidden${xn}`,
    Hn = `resize${xn}`,
    Wn = `click${xn}${kn}`,
    Bn = `keydown.dismiss${xn}`,
    zn = {
      backdrop: !0,
      keyboard: !0,
      scroll: !1
    },
    Rn = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean"
    };
  class qn extends W {
    constructor(t, e) {
      super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
    }
    static get Default() {
      return zn;
    }
    static get DefaultType() {
      return Rn;
    }
    static get NAME() {
      return "offcanvas";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown || N.trigger(this._element, Nn, {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || new cn().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Dn), this._queueCallback(() => {
        this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Sn), this._element.classList.remove(Dn), N.trigger(this._element, Pn, {
          relatedTarget: t
        });
      }, this._element, !0));
    }
    hide() {
      this._isShown && (N.trigger(this._element, jn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add($n), this._backdrop.hide(), this._queueCallback(() => {
        this._element.classList.remove(Sn, $n), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new cn().reset(), N.trigger(this._element, Fn);
      }, this._element, !0)));
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    _initializeBackDrop() {
      const t = Boolean(this._config.backdrop);
      return new Ui({
        className: "offcanvas-backdrop",
        isVisible: t,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: t ? () => {
          "static" !== this._config.backdrop ? this.hide() : N.trigger(this._element, Mn);
        } : null
      });
    }
    _initializeFocusTrap() {
      return new sn({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      N.on(this._element, Bn, t => {
        "Escape" === t.key && (this._config.keyboard ? this.hide() : N.trigger(this._element, Mn));
      });
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = qn.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  N.on(document, Wn, '[data-bs-toggle="offcanvas"]', function (t) {
    const e = z.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this)) return;
    N.one(e, Fn, () => {
      a(this) && this.focus();
    });
    const i = z.findOne(In);
    i && i !== e && qn.getInstance(i).hide(), qn.getOrCreateInstance(e).toggle(this);
  }), N.on(window, Ln, () => {
    for (const t of z.find(In)) qn.getOrCreateInstance(t).show();
  }), N.on(window, Hn, () => {
    for (const t of z.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && qn.getOrCreateInstance(t).hide();
  }), R(qn), m(qn);
  const Vn = {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      dd: [],
      div: [],
      dl: [],
      dt: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    },
    Kn = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    Qn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
    Xn = (t, e) => {
      const i = t.nodeName.toLowerCase();
      return e.includes(i) ? !Kn.has(i) || Boolean(Qn.test(t.nodeValue)) : e.filter(t => t instanceof RegExp).some(t => t.test(i));
    },
    Yn = {
      allowList: Vn,
      content: {},
      extraClass: "",
      html: !1,
      sanitize: !0,
      sanitizeFn: null,
      template: "<div></div>"
    },
    Un = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string"
    },
    Gn = {
      entry: "(string|element|function|null)",
      selector: "(string|element)"
    };
  class Jn extends H {
    constructor(t) {
      super(), this._config = this._getConfig(t);
    }
    static get Default() {
      return Yn;
    }
    static get DefaultType() {
      return Un;
    }
    static get NAME() {
      return "TemplateFactory";
    }
    getContent() {
      return Object.values(this._config.content).map(t => this._resolvePossibleFunction(t)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(t) {
      return this._checkContent(t), this._config.content = {
        ...this._config.content,
        ...t
      }, this;
    }
    toHtml() {
      const t = document.createElement("div");
      t.innerHTML = this._maybeSanitize(this._config.template);
      for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
      const e = t.children[0],
        i = this._resolvePossibleFunction(this._config.extraClass);
      return i && e.classList.add(...i.split(" ")), e;
    }
    _typeCheckConfig(t) {
      super._typeCheckConfig(t), this._checkContent(t.content);
    }
    _checkContent(t) {
      for (const [e, i] of Object.entries(t)) super._typeCheckConfig({
        selector: e,
        entry: i
      }, Gn);
    }
    _setContent(t, e, i) {
      const n = z.findOne(i, t);
      n && ((e = this._resolvePossibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove());
    }
    _maybeSanitize(t) {
      return this._config.sanitize ? function (t, e, i) {
        if (!t.length) return t;
        if (i && "function" == typeof i) return i(t);
        const n = new window.DOMParser().parseFromString(t, "text/html"),
          s = [].concat(...n.body.querySelectorAll("*"));
        for (const t of s) {
          const i = t.nodeName.toLowerCase();
          if (!Object.keys(e).includes(i)) {
            t.remove();
            continue;
          }
          const n = [].concat(...t.attributes),
            s = [].concat(e["*"] || [], e[i] || []);
          for (const e of n) Xn(e, s) || t.removeAttribute(e.nodeName);
        }
        return n.body.innerHTML;
      }(t, this._config.allowList, this._config.sanitizeFn) : t;
    }
    _resolvePossibleFunction(t) {
      return g(t, [this]);
    }
    _putElementInTemplate(t, e) {
      if (this._config.html) return e.innerHTML = "", void e.append(t);
      e.textContent = t.textContent;
    }
  }
  const Zn = new Set(["sanitize", "allowList", "sanitizeFn"]),
    ts = "fade",
    es = "show",
    is = ".modal",
    ns = "hide.bs.modal",
    ss = "hover",
    os = "focus",
    rs = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: p() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: p() ? "right" : "left"
    },
    as = {
      allowList: Vn,
      animation: !0,
      boundary: "clippingParents",
      container: !1,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: !1,
      offset: [0, 6],
      placement: "top",
      popperConfig: null,
      sanitize: !0,
      sanitizeFn: null,
      selector: !1,
      template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: "",
      trigger: "hover focus"
    },
    ls = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string"
    };
  class cs extends W {
    constructor(t, e) {
      if (void 0 === vi) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
    }
    static get Default() {
      return as;
    }
    static get DefaultType() {
      return ls;
    }
    static get NAME() {
      return "tooltip";
    }
    enable() {
      this._isEnabled = !0;
    }
    disable() {
      this._isEnabled = !1;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter());
    }
    dispose() {
      clearTimeout(this._timeout), N.off(this._element.closest(is), ns, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
    }
    show() {
      if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
      if (!this._isWithContent() || !this._isEnabled) return;
      const t = N.trigger(this._element, this.constructor.eventName("show")),
        e = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
      if (t.defaultPrevented || !e) return;
      this._disposePopper();
      const i = this._getTipElement();
      this._element.setAttribute("aria-describedby", i.getAttribute("id"));
      const {
        container: n
      } = this._config;
      if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), N.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(es), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) N.on(t, "mouseover", h);
      this._queueCallback(() => {
        N.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1;
      }, this.tip, this._isAnimated());
    }
    hide() {
      if (this._isShown() && !N.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
        if (this._getTipElement().classList.remove(es), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) N.off(t, "mouseover", h);
        this._activeTrigger.click = !1, this._activeTrigger[os] = !1, this._activeTrigger[ss] = !1, this._isHovered = null, this._queueCallback(() => {
          this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), N.trigger(this._element, this.constructor.eventName("hidden")));
        }, this.tip, this._isAnimated());
      }
    }
    update() {
      this._popper && this._popper.update();
    }
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
    }
    _createTipElement(t) {
      const e = this._getTemplateFactory(t).toHtml();
      if (!e) return null;
      e.classList.remove(ts, es), e.classList.add(`bs-${this.constructor.NAME}-auto`);
      const i = (t => {
        do {
          t += Math.floor(1e6 * Math.random());
        } while (document.getElementById(t));
        return t;
      })(this.constructor.NAME).toString();
      return e.setAttribute("id", i), this._isAnimated() && e.classList.add(ts), e;
    }
    setContent(t) {
      this._newContent = t, this._isShown() && (this._disposePopper(), this.show());
    }
    _getTemplateFactory(t) {
      return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Jn({
        ...this._config,
        content: t,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      }), this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        ".tooltip-inner": this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    _initializeOnDelegatedTarget(t) {
      return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(ts);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(es);
    }
    _createPopper(t) {
      const e = g(this._config.placement, [this, t, this._element]),
        i = rs[e.toUpperCase()];
      return bi(this._element, t, this._getPopperConfig(i));
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;
    }
    _resolvePossibleFunction(t) {
      return g(t, [this._element]);
    }
    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: !0,
          phase: "beforeMain",
          fn: t => {
            this._getTipElement().setAttribute("data-popper-placement", t.state.placement);
          }
        }]
      };
      return {
        ...e,
        ...g(this._config.popperConfig, [e])
      };
    }
    _setListeners() {
      const t = this._config.trigger.split(" ");
      for (const e of t) if ("click" === e) N.on(this._element, this.constructor.eventName("click"), this._config.selector, t => {
        this._initializeOnDelegatedTarget(t).toggle();
      });else if ("manual" !== e) {
        const t = e === ss ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
          i = e === ss ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
        N.on(this._element, t, this._config.selector, t => {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger["focusin" === t.type ? os : ss] = !0, e._enter();
        }), N.on(this._element, i, this._config.selector, t => {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger["focusout" === t.type ? os : ss] = e._element.contains(t.relatedTarget), e._leave();
        });
      }
      this._hideModalHandler = () => {
        this._element && this.hide();
      }, N.on(this._element.closest(is), ns, this._hideModalHandler);
    }
    _fixTitle() {
      const t = this._element.getAttribute("title");
      t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"));
    }
    _enter() {
      this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => {
        this._isHovered && this.show();
      }, this._config.delay.show));
    }
    _leave() {
      this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
        this._isHovered || this.hide();
      }, this._config.delay.hide));
    }
    _setTimeout(t, e) {
      clearTimeout(this._timeout), this._timeout = setTimeout(t, e);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(!0);
    }
    _getConfig(t) {
      const e = F.getDataAttributes(this._element);
      for (const t of Object.keys(e)) Zn.has(t) && delete e[t];
      return t = {
        ...e,
        ...("object" == typeof t && t ? t : {})
      }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
    }
    _configAfterMerge(t) {
      return t.container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t;
    }
    _getDelegateConfig() {
      const t = {};
      for (const [e, i] of Object.entries(this._config)) this.constructor.Default[e] !== i && (t[e] = i);
      return t.selector = !1, t.trigger = "manual", t;
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = cs.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  m(cs);
  const hs = {
      ...cs.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: "click"
    },
    ds = {
      ...cs.DefaultType,
      content: "(null|string|element|function)"
    };
  class us extends cs {
    static get Default() {
      return hs;
    }
    static get DefaultType() {
      return ds;
    }
    static get NAME() {
      return "popover";
    }
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    _getContentForTemplate() {
      return {
        ".popover-header": this._getTitle(),
        ".popover-body": this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = us.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  m(us);
  const fs = ".bs.scrollspy",
    ps = `activate${fs}`,
    ms = `click${fs}`,
    gs = `load${fs}.data-api`,
    _s = "active",
    bs = "[href]",
    vs = ".nav-link",
    ys = `${vs}, .nav-item > ${vs}, .list-group-item`,
    ws = {
      offset: null,
      rootMargin: "0px 0px -25%",
      smoothScroll: !1,
      target: null,
      threshold: [.1, .5, 1]
    },
    As = {
      offset: "(number|null)",
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element",
      threshold: "array"
    };
  class Es extends W {
    constructor(t, e) {
      super(t, e), this._targetLinks = new Map(), this._observableSections = new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      }, this.refresh();
    }
    static get Default() {
      return ws;
    }
    static get DefaultType() {
      return As;
    }
    static get NAME() {
      return "scrollspy";
    }
    refresh() {
      this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
      for (const t of this._observableSections.values()) this._observer.observe(t);
    }
    dispose() {
      this._observer.disconnect(), super.dispose();
    }
    _configAfterMerge(t) {
      return t.target = r(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map(t => Number.parseFloat(t))), t;
    }
    _maybeEnableSmoothScroll() {
      this._config.smoothScroll && (N.off(this._config.target, ms), N.on(this._config.target, ms, bs, t => {
        const e = this._observableSections.get(t.target.hash);
        if (e) {
          t.preventDefault();
          const i = this._rootElement || window,
            n = e.offsetTop - this._element.offsetTop;
          if (i.scrollTo) return void i.scrollTo({
            top: n,
            behavior: "smooth"
          });
          i.scrollTop = n;
        }
      }));
    }
    _getNewObserver() {
      const t = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver(t => this._observerCallback(t), t);
    }
    _observerCallback(t) {
      const e = t => this._targetLinks.get(`#${t.target.id}`),
        i = t => {
          this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t));
        },
        n = (this._rootElement || document.documentElement).scrollTop,
        s = n >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = n;
      for (const o of t) {
        if (!o.isIntersecting) {
          this._activeTarget = null, this._clearActiveClass(e(o));
          continue;
        }
        const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (s && t) {
          if (i(o), !n) return;
        } else s || t || i(o);
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = new Map(), this._observableSections = new Map();
      const t = z.find(bs, this._config.target);
      for (const e of t) {
        if (!e.hash || l(e)) continue;
        const t = z.findOne(decodeURI(e.hash), this._element);
        a(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t));
      }
    }
    _process(t) {
      this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(_s), this._activateParents(t), N.trigger(this._element, ps, {
        relatedTarget: t
      }));
    }
    _activateParents(t) {
      if (t.classList.contains("dropdown-item")) z.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(_s);else for (const e of z.parents(t, ".nav, .list-group")) for (const t of z.prev(e, ys)) t.classList.add(_s);
    }
    _clearActiveClass(t) {
      t.classList.remove(_s);
      const e = z.find(`${bs}.${_s}`, t);
      for (const t of e) t.classList.remove(_s);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Es.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  N.on(window, gs, () => {
    for (const t of z.find('[data-bs-spy="scroll"]')) Es.getOrCreateInstance(t);
  }), m(Es);
  const Ts = ".bs.tab",
    Cs = `hide${Ts}`,
    Os = `hidden${Ts}`,
    xs = `show${Ts}`,
    ks = `shown${Ts}`,
    Ls = `click${Ts}`,
    Ss = `keydown${Ts}`,
    Ds = `load${Ts}`,
    $s = "ArrowLeft",
    Is = "ArrowRight",
    Ns = "ArrowUp",
    Ps = "ArrowDown",
    js = "Home",
    Ms = "End",
    Fs = "active",
    Hs = "fade",
    Ws = "show",
    Bs = ".dropdown-toggle",
    zs = `:not(${Bs})`,
    Rs = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    qs = `.nav-link${zs}, .list-group-item${zs}, [role="tab"]${zs}, ${Rs}`,
    Vs = `.${Fs}[data-bs-toggle="tab"], .${Fs}[data-bs-toggle="pill"], .${Fs}[data-bs-toggle="list"]`;
  class Ks extends W {
    constructor(t) {
      super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), N.on(this._element, Ss, t => this._keydown(t)));
    }
    static get NAME() {
      return "tab";
    }
    show() {
      const t = this._element;
      if (this._elemIsActive(t)) return;
      const e = this._getActiveElem(),
        i = e ? N.trigger(e, Cs, {
          relatedTarget: t
        }) : null;
      N.trigger(t, xs, {
        relatedTarget: e
      }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
    }
    _activate(t, e) {
      t && (t.classList.add(Fs), this._activate(z.getElementFromSelector(t)), this._queueCallback(() => {
        "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), N.trigger(t, ks, {
          relatedTarget: e
        })) : t.classList.add(Ws);
      }, t, t.classList.contains(Hs)));
    }
    _deactivate(t, e) {
      t && (t.classList.remove(Fs), t.blur(), this._deactivate(z.getElementFromSelector(t)), this._queueCallback(() => {
        "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), N.trigger(t, Os, {
          relatedTarget: e
        })) : t.classList.remove(Ws);
      }, t, t.classList.contains(Hs)));
    }
    _keydown(t) {
      if (![$s, Is, Ns, Ps, js, Ms].includes(t.key)) return;
      t.stopPropagation(), t.preventDefault();
      const e = this._getChildren().filter(t => !l(t));
      let i;
      if ([js, Ms].includes(t.key)) i = e[t.key === js ? 0 : e.length - 1];else {
        const n = [Is, Ps].includes(t.key);
        i = b(e, t.target, n, !0);
      }
      i && (i.focus({
        preventScroll: !0
      }), Ks.getOrCreateInstance(i).show());
    }
    _getChildren() {
      return z.find(qs, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find(t => this._elemIsActive(t)) || null;
    }
    _setInitialAttributes(t, e) {
      this._setAttributeIfNotExists(t, "role", "tablist");
      for (const t of e) this._setInitialAttributesOnChild(t);
    }
    _setInitialAttributesOnChild(t) {
      t = this._getInnerElement(t);
      const e = this._elemIsActive(t),
        i = this._getOuterElement(t);
      t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t);
    }
    _setInitialAttributesOnTargetPanel(t) {
      const e = z.getElementFromSelector(t);
      e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
    }
    _toggleDropDown(t, e) {
      const i = this._getOuterElement(t);
      if (!i.classList.contains("dropdown")) return;
      const n = (t, n) => {
        const s = z.findOne(t, i);
        s && s.classList.toggle(n, e);
      };
      n(Bs, Fs), n(".dropdown-menu", Ws), i.setAttribute("aria-expanded", e);
    }
    _setAttributeIfNotExists(t, e, i) {
      t.hasAttribute(e) || t.setAttribute(e, i);
    }
    _elemIsActive(t) {
      return t.classList.contains(Fs);
    }
    _getInnerElement(t) {
      return t.matches(qs) ? t : z.findOne(qs, t);
    }
    _getOuterElement(t) {
      return t.closest(".nav-item, .list-group-item") || t;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Ks.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  N.on(document, Ls, Rs, function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this) || Ks.getOrCreateInstance(this).show();
  }), N.on(window, Ds, () => {
    for (const t of z.find(Vs)) Ks.getOrCreateInstance(t);
  }), m(Ks);
  const Qs = ".bs.toast",
    Xs = `mouseover${Qs}`,
    Ys = `mouseout${Qs}`,
    Us = `focusin${Qs}`,
    Gs = `focusout${Qs}`,
    Js = `hide${Qs}`,
    Zs = `hidden${Qs}`,
    to = `show${Qs}`,
    eo = `shown${Qs}`,
    io = "hide",
    no = "show",
    so = "showing",
    oo = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    },
    ro = {
      animation: !0,
      autohide: !0,
      delay: 5e3
    };
  class ao extends W {
    constructor(t, e) {
      super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
    }
    static get Default() {
      return ro;
    }
    static get DefaultType() {
      return oo;
    }
    static get NAME() {
      return "toast";
    }
    show() {
      N.trigger(this._element, to).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(io), d(this._element), this._element.classList.add(no, so), this._queueCallback(() => {
        this._element.classList.remove(so), N.trigger(this._element, eo), this._maybeScheduleHide();
      }, this._element, this._config.animation));
    }
    hide() {
      this.isShown() && (N.trigger(this._element, Js).defaultPrevented || (this._element.classList.add(so), this._queueCallback(() => {
        this._element.classList.add(io), this._element.classList.remove(so, no), N.trigger(this._element, Zs);
      }, this._element, this._config.animation)));
    }
    dispose() {
      this._clearTimeout(), this.isShown() && this._element.classList.remove(no), super.dispose();
    }
    isShown() {
      return this._element.classList.contains(no);
    }
    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay)));
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }
      if (e) return void this._clearTimeout();
      const i = t.relatedTarget;
      this._element === i || this._element.contains(i) || this._maybeScheduleHide();
    }
    _setListeners() {
      N.on(this._element, Xs, t => this._onInteraction(t, !0)), N.on(this._element, Ys, t => this._onInteraction(t, !1)), N.on(this._element, Us, t => this._onInteraction(t, !0)), N.on(this._element, Gs, t => this._onInteraction(t, !1));
    }
    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = ao.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  return R(ao), m(ao), {
    Alert: Q,
    Button: Y,
    Carousel: xt,
    Collapse: Bt,
    Dropdown: qi,
    Modal: On,
    Offcanvas: qn,
    Popover: us,
    ScrollSpy: Es,
    Tab: Ks,
    Toast: ao,
    Tooltip: cs
  };
});
var Datepicker = function () {
  "use strict";

  function e(e) {
    return e[e.length - 1];
  }
  function t(e, ...t) {
    return t.forEach(t => {
      e.includes(t) || e.push(t);
    }), e;
  }
  function i(e, t) {
    return e ? e.split(t) : [];
  }
  function n(e, t, i) {
    return (void 0 === t || e >= t) && (void 0 === i || e <= i);
  }
  function s(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  function a(e, t, i = {}, n = 0, s = "") {
    s += `<${Object.keys(i).reduce((e, t) => {
      let s = i[t];
      return "function" == typeof s && (s = s(n)), `${e} ${t}="${s}"`;
    }, e)}></${e}>`;
    const r = n + 1;
    return r < t ? a(e, t, i, r, s) : s;
  }
  function r(e) {
    return e.replace(/>\s+/g, ">").replace(/\s+</, "<");
  }
  function o(e) {
    return new Date(e).setHours(0, 0, 0, 0);
  }
  function d() {
    return new Date().setHours(0, 0, 0, 0);
  }
  function c(...e) {
    switch (e.length) {
      case 0:
        return d();
      case 1:
        return o(e[0]);
    }
    const t = new Date(0);
    return t.setFullYear(...e), t.setHours(0, 0, 0, 0);
  }
  function l(e, t) {
    const i = new Date(e);
    return i.setDate(i.getDate() + t);
  }
  function h(e, t) {
    const i = new Date(e),
      n = i.getMonth() + t;
    let s = n % 12;
    s < 0 && (s += 12);
    const a = i.setMonth(n);
    return i.getMonth() !== s ? i.setDate(0) : a;
  }
  function u(e, t) {
    const i = new Date(e),
      n = i.getMonth(),
      s = i.setFullYear(i.getFullYear() + t);
    return 1 === n && 2 === i.getMonth() ? i.setDate(0) : s;
  }
  function f(e, t) {
    return (e - t + 7) % 7;
  }
  function p(e, t, i = 0) {
    const n = new Date(e).getDay();
    return l(e, f(t, i) - f(n, i));
  }
  function m(e, t) {
    return Math.round((e - t) / 6048e5) + 1;
  }
  function w(e) {
    const t = p(e, 4, 1);
    return m(t, p(new Date(t).setMonth(0, 4), 4, 1));
  }
  function g(e, t) {
    const i = p(new Date(e).setMonth(0, 1), t, t),
      n = p(e, t, t),
      s = m(n, i);
    if (s < 53) return s;
    return n === p(new Date(e).setDate(32), t, t) ? 1 : s;
  }
  function y(e) {
    return g(e, 0);
  }
  function D(e) {
    return g(e, 6);
  }
  function k(e, t) {
    const i = new Date(e).getFullYear();
    return Math.floor(i / t) * t;
  }
  function b(e, t, i) {
    if (1 !== t && 2 !== t) return e;
    const n = new Date(e);
    return 1 === t ? i ? n.setMonth(n.getMonth() + 1, 0) : n.setDate(1) : i ? n.setFullYear(n.getFullYear() + 1, 0, 0) : n.setMonth(0, 1), n.setHours(0, 0, 0, 0);
  }
  const v = /dd?|DD?|mm?|MM?|yy?(?:yy)?/,
    x = /[\s!-/:-@[-`{-~年月日]+/;
  let M = {};
  const N = {
      y: (e, t) => new Date(e).setFullYear(parseInt(t, 10)),
      m(e, t, i) {
        const n = new Date(e);
        let s = parseInt(t, 10) - 1;
        if (isNaN(s)) {
          if (!t) return NaN;
          const e = t.toLowerCase(),
            n = t => t.toLowerCase().startsWith(e);
          if (s = i.monthsShort.findIndex(n), s < 0 && (s = i.months.findIndex(n)), s < 0) return NaN;
        }
        return n.setMonth(s), n.getMonth() !== O(s) ? n.setDate(0) : n.getTime();
      },
      d: (e, t) => new Date(e).setDate(parseInt(t, 10))
    },
    S = {
      d: e => e.getDate(),
      dd: e => C(e.getDate(), 2),
      D: (e, t) => t.daysShort[e.getDay()],
      DD: (e, t) => t.days[e.getDay()],
      m: e => e.getMonth() + 1,
      mm: e => C(e.getMonth() + 1, 2),
      M: (e, t) => t.monthsShort[e.getMonth()],
      MM: (e, t) => t.months[e.getMonth()],
      y: e => e.getFullYear(),
      yy: e => C(e.getFullYear(), 2).slice(-2),
      yyyy: e => C(e.getFullYear(), 4)
    };
  function O(e) {
    return e > -1 ? e % 12 : O(e + 12);
  }
  function C(e, t) {
    return e.toString().padStart(t, "0");
  }
  function F(t) {
    if ("string" != typeof t) throw new Error("Invalid date format.");
    if (t in M) return M[t];
    const i = t.split(v),
      n = t.match(new RegExp(v, "g"));
    if (0 === i.length || !n) throw new Error("Invalid date format.");
    const s = n.map(e => S[e]),
      a = Object.keys(N).reduce((e, t) => (n.find(e => "D" !== e[0] && e[0].toLowerCase() === t) && e.push(t), e), []);
    return M[t] = {
      parser(e, t) {
        const i = e.split(x).reduce((e, t, i) => {
          if (t.length > 0 && n[i]) {
            const s = n[i][0];
            "M" === s ? e.m = t : "D" !== s && (e[s] = t);
          }
          return e;
        }, {});
        return a.reduce((e, n) => {
          const s = N[n](e, i[n], t);
          return isNaN(s) ? e : s;
        }, d());
      },
      formatter: (t, n) => s.reduce((e, s, a) => e + `${i[a]}${s(t, n)}`, "") + e(i)
    };
  }
  function V(e, t, i) {
    if (e instanceof Date || "number" == typeof e) {
      const t = o(e);
      return isNaN(t) ? void 0 : t;
    }
    if (e) {
      if ("today" === e) return d();
      if (t && t.toValue) {
        const n = t.toValue(e, t, i);
        return isNaN(n) ? void 0 : o(n);
      }
      return F(t).parser(e, i);
    }
  }
  function B(e, t, i) {
    if (isNaN(e) || !e && 0 !== e) return "";
    const n = "number" == typeof e ? new Date(e) : e;
    return t.toDisplay ? t.toDisplay(n, t, i) : F(t).formatter(n, i);
  }
  const E = document.createRange();
  function L(e) {
    return E.createContextualFragment(e);
  }
  function A(e) {
    return e.parentElement || (e.parentNode instanceof ShadowRoot ? e.parentNode.host : void 0);
  }
  function Y(e) {
    return e.getRootNode().activeElement === e;
  }
  function W(e) {
    "none" !== e.style.display && (e.style.display && (e.dataset.styleDisplay = e.style.display), e.style.display = "none");
  }
  function K(e) {
    "none" === e.style.display && (e.dataset.styleDisplay ? (e.style.display = e.dataset.styleDisplay, delete e.dataset.styleDisplay) : e.style.display = "");
  }
  function _(e) {
    e.firstChild && (e.removeChild(e.firstChild), _(e));
  }
  const T = new WeakMap(),
    {
      addEventListener: H,
      removeEventListener: j
    } = EventTarget.prototype;
  function R(e, t) {
    let i = T.get(e);
    i || (i = [], T.set(e, i)), t.forEach(e => {
      H.call(...e), i.push(e);
    });
  }
  if (!Event.prototype.composedPath) {
    const e = (t, i = []) => {
      let n;
      return i.push(t), t.parentNode ? n = t.parentNode : t.host ? n = t.host : t.defaultView && (n = t.defaultView), n ? e(n, i) : i;
    };
    Event.prototype.composedPath = function () {
      return e(this.target);
    };
  }
  function $(e, t, i) {
    const [n, ...s] = e;
    return t(n) ? n : n !== i && "HTML" !== n.tagName && 0 !== s.length ? $(s, t, i) : void 0;
  }
  function I(e, t) {
    const i = "function" == typeof t ? t : e => e instanceof Element && e.matches(t);
    return $(e.composedPath(), i, e.currentTarget);
  }
  const P = {
      en: {
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        today: "Today",
        clear: "Clear",
        titleFormat: "MM y"
      }
    },
    J = {
      autohide: !1,
      beforeShowDay: null,
      beforeShowDecade: null,
      beforeShowMonth: null,
      beforeShowYear: null,
      clearButton: !1,
      dateDelimiter: ",",
      datesDisabled: [],
      daysOfWeekDisabled: [],
      daysOfWeekHighlighted: [],
      defaultViewDate: void 0,
      disableTouchKeyboard: !1,
      enableOnReadonly: !0,
      format: "mm/dd/yyyy",
      language: "en",
      maxDate: null,
      maxNumberOfDates: 1,
      maxView: 3,
      minDate: null,
      nextArrow: "»",
      orientation: "auto",
      pickLevel: 0,
      prevArrow: "«",
      showDaysOfWeek: !0,
      showOnClick: !0,
      showOnFocus: !0,
      startView: 0,
      title: "",
      todayButton: !1,
      todayButtonMode: 0,
      todayHighlight: !1,
      updateOnBlur: !0,
      weekNumbers: 0,
      weekStart: 0
    },
    {
      language: U,
      format: q,
      weekStart: z
    } = J;
  function X(e, i) {
    return e.length < 6 && i >= 0 && i < 7 ? t(e, i) : e;
  }
  function G(e, t) {
    switch (4 === e ? 6 === t ? 3 : !t + 1 : e) {
      case 1:
        return w;
      case 2:
        return y;
      case 3:
        return D;
    }
  }
  function Q(e, t, i) {
    return t.weekStart = e, t.weekEnd = (e + 6) % 7, 4 === i && (t.getWeekNumber = G(4, e)), e;
  }
  function Z(e, t, i, n) {
    const s = V(e, t, i);
    return void 0 !== s ? s : n;
  }
  function ee(e, t, i = 3) {
    const n = parseInt(e, 10);
    return n >= 0 && n <= i ? n : t;
  }
  function te(e, t, i, n = void 0) {
    t in e && (i in e || (e[i] = n ? n(e[t]) : e[t]), delete e[t]);
  }
  function ie(e, i) {
    const n = Object.assign({}, e),
      s = {},
      a = i.constructor.locales,
      r = !!i.rangeSideIndex;
    let {
      datesDisabled: o,
      format: d,
      language: l,
      locale: h,
      maxDate: u,
      maxView: f,
      minDate: p,
      pickLevel: m,
      startView: w,
      weekNumbers: g,
      weekStart: y
    } = i.config || {};
    if (te(n, "calendarWeeks", "weekNumbers", e => e ? 1 : 0), te(n, "clearBtn", "clearButton"), te(n, "todayBtn", "todayButton"), te(n, "todayBtnMode", "todayButtonMode"), n.language) {
      let e;
      if (n.language !== l && (a[n.language] ? e = n.language : (e = n.language.split("-")[0], a[e] || (e = !1))), delete n.language, e) {
        l = s.language = e;
        const t = h || a[U];
        h = Object.assign({
          format: q,
          weekStart: z
        }, a[U]), l !== U && Object.assign(h, a[l]), s.locale = h, d === t.format && (d = s.format = h.format), y === t.weekStart && (y = Q(h.weekStart, s, g));
      }
    }
    if (n.format) {
      const e = "function" == typeof n.format.toDisplay,
        t = "function" == typeof n.format.toValue,
        i = v.test(n.format);
      (e && t || i) && (d = s.format = n.format), delete n.format;
    }
    let D = m;
    "pickLevel" in n && (D = ee(n.pickLevel, m, 2), delete n.pickLevel), D !== m && (D > m && ("minDate" in n || (n.minDate = p), "maxDate" in n || (n.maxDate = u)), o && !n.datesDisabled && (n.datesDisabled = []), m = s.pickLevel = D);
    let k = p,
      x = u;
    if ("minDate" in n) {
      const e = c(0, 0, 1);
      k = null === n.minDate ? e : Z(n.minDate, d, h, k), k !== e && (k = b(k, m, !1)), delete n.minDate;
    }
    if ("maxDate" in n && (x = null === n.maxDate ? void 0 : Z(n.maxDate, d, h, x), void 0 !== x && (x = b(x, m, !0)), delete n.maxDate), x < k ? (p = s.minDate = x, u = s.maxDate = k) : (p !== k && (p = s.minDate = k), u !== x && (u = s.maxDate = x)), n.datesDisabled) {
      const e = n.datesDisabled;
      if ("function" == typeof e) s.datesDisabled = null, s.checkDisabled = (t, i) => e(new Date(t), i, r);else {
        const i = s.datesDisabled = e.reduce((e, i) => {
          const n = V(i, d, h);
          return void 0 !== n ? t(e, b(n, m, r)) : e;
        }, []);
        s.checkDisabled = e => i.includes(e);
      }
      delete n.datesDisabled;
    }
    if ("defaultViewDate" in n) {
      const e = V(n.defaultViewDate, d, h);
      void 0 !== e && (s.defaultViewDate = e), delete n.defaultViewDate;
    }
    if ("weekStart" in n) {
      const e = Number(n.weekStart) % 7;
      isNaN(e) || (y = Q(e, s, g)), delete n.weekStart;
    }
    if (n.daysOfWeekDisabled && (s.daysOfWeekDisabled = n.daysOfWeekDisabled.reduce(X, []), delete n.daysOfWeekDisabled), n.daysOfWeekHighlighted && (s.daysOfWeekHighlighted = n.daysOfWeekHighlighted.reduce(X, []), delete n.daysOfWeekHighlighted), "weekNumbers" in n) {
      let e = n.weekNumbers;
      if (e) {
        const t = "function" == typeof e ? (t, i) => e(new Date(t), i) : G(e = parseInt(e, 10), y);
        t && (g = s.weekNumbers = e, s.getWeekNumber = t);
      } else g = s.weekNumbers = 0, s.getWeekNumber = null;
      delete n.weekNumbers;
    }
    if ("maxNumberOfDates" in n) {
      const e = parseInt(n.maxNumberOfDates, 10);
      e >= 0 && (s.maxNumberOfDates = e, s.multidate = 1 !== e), delete n.maxNumberOfDates;
    }
    n.dateDelimiter && (s.dateDelimiter = String(n.dateDelimiter), delete n.dateDelimiter);
    let M = f;
    "maxView" in n && (M = ee(n.maxView, f), delete n.maxView), M = m > M ? m : M, M !== f && (f = s.maxView = M);
    let N = w;
    if ("startView" in n && (N = ee(n.startView, N), delete n.startView), N < m ? N = m : N > f && (N = f), N !== w && (s.startView = N), n.prevArrow) {
      const e = L(n.prevArrow);
      e.childNodes.length > 0 && (s.prevArrow = e.childNodes), delete n.prevArrow;
    }
    if (n.nextArrow) {
      const e = L(n.nextArrow);
      e.childNodes.length > 0 && (s.nextArrow = e.childNodes), delete n.nextArrow;
    }
    if ("disableTouchKeyboard" in n && (s.disableTouchKeyboard = "ontouchstart" in document && !!n.disableTouchKeyboard, delete n.disableTouchKeyboard), n.orientation) {
      const e = n.orientation.toLowerCase().split(/\s+/g);
      s.orientation = {
        x: e.find(e => "left" === e || "right" === e) || "auto",
        y: e.find(e => "top" === e || "bottom" === e) || "auto"
      }, delete n.orientation;
    }
    if ("todayButtonMode" in n) {
      switch (n.todayButtonMode) {
        case 0:
        case 1:
          s.todayButtonMode = n.todayButtonMode;
      }
      delete n.todayButtonMode;
    }
    return Object.entries(n).forEach(([e, t]) => {
      void 0 !== t && e in J && (s[e] = t);
    }), s;
  }
  const ne = {
    show: {
      key: "ArrowDown"
    },
    hide: null,
    toggle: {
      key: "Escape"
    },
    prevButton: {
      key: "ArrowLeft",
      ctrlOrMetaKey: !0
    },
    nextButton: {
      key: "ArrowRight",
      ctrlOrMetaKey: !0
    },
    viewSwitch: {
      key: "ArrowUp",
      ctrlOrMetaKey: !0
    },
    clearButton: {
      key: "Backspace",
      ctrlOrMetaKey: !0
    },
    todayButton: {
      key: ".",
      ctrlOrMetaKey: !0
    },
    exitEditMode: {
      key: "ArrowDown",
      ctrlOrMetaKey: !0
    }
  };
  const se = e => e.map(e => `<button type="button" class="%buttonClass% ${e}" tabindex="-1"></button>`).join(""),
    ae = r(`<div class="datepicker">\n  <div class="datepicker-picker">\n    <div class="datepicker-header">\n      <div class="datepicker-title"></div>\n      <div class="datepicker-controls">\n        ${se(["prev-button prev-btn", "view-switch", "next-button next-btn"])}\n      </div>\n    </div>\n    <div class="datepicker-main"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls">\n        ${se(["today-button today-btn", "clear-button clear-btn"])}\n      </div>\n    </div>\n  </div>\n</div>`),
    re = r(`<div class="days">\n  <div class="days-of-week">${a("span", 7, {
      class: "dow"
    })}</div>\n  <div class="datepicker-grid">${a("span", 42)}</div>\n</div>`),
    oe = r(`<div class="week-numbers calendar-weeks">\n  <div class="days-of-week"><span class="dow"></span></div>\n  <div class="weeks">${a("span", 6, {
      class: "week"
    })}</div>\n</div>`);
  class de {
    constructor(e, t) {
      Object.assign(this, t, {
        picker: e,
        element: L('<div class="datepicker-view"></div>').firstChild,
        selected: [],
        isRangeEnd: !!e.datepicker.rangeSideIndex
      }), this.init(this.picker.datepicker.config);
    }
    init(e) {
      "pickLevel" in e && (this.isMinView = this.id === e.pickLevel), this.setOptions(e), this.updateFocus(), this.updateSelection();
    }
    prepareForRender(e, t, i) {
      this.disabled = [];
      const n = this.picker;
      n.setViewSwitchLabel(e), n.setPrevButtonDisabled(t), n.setNextButtonDisabled(i);
    }
    setDisabled(e, i) {
      i.add("disabled"), t(this.disabled, e);
    }
    performBeforeHook(e, t) {
      let i = this.beforeShow(new Date(t));
      switch (typeof i) {
        case "boolean":
          i = {
            enabled: i
          };
          break;
        case "string":
          i = {
            classes: i
          };
      }
      if (i) {
        const n = e.classList;
        if (!1 === i.enabled && this.setDisabled(t, n), i.classes) {
          const e = i.classes.split(/\s+/);
          n.add(...e), e.includes("disabled") && this.setDisabled(t, n);
        }
        i.content && function (e, t) {
          _(e), t instanceof DocumentFragment ? e.appendChild(t) : "string" == typeof t ? e.appendChild(L(t)) : "function" == typeof t.forEach && t.forEach(t => {
            e.appendChild(t);
          });
        }(e, i.content);
      }
    }
    renderCell(e, t, i, n, {
      selected: s,
      range: a
    }, r, o = []) {
      e.textContent = t, this.isMinView && (e.dataset.date = n);
      const d = e.classList;
      if (e.className = `datepicker-cell ${this.cellClass}`, i < this.first ? d.add("prev") : i > this.last && d.add("next"), d.add(...o), (r || this.checkDisabled(n, this.id)) && this.setDisabled(n, d), a) {
        const [e, t] = a;
        i > e && i < t && d.add("range"), i === e && d.add("range-start"), i === t && d.add("range-end");
      }
      s.includes(i) && d.add("selected"), i === this.focused && d.add("focused"), this.beforeShow && this.performBeforeHook(e, n);
    }
    refreshCell(e, t, i, [n, s]) {
      const a = e.classList;
      a.remove("range", "range-start", "range-end", "selected", "focused"), t > n && t < s && a.add("range"), t === n && a.add("range-start"), t === s && a.add("range-end"), i.includes(t) && a.add("selected"), t === this.focused && a.add("focused");
    }
    changeFocusedCell(e) {
      this.grid.querySelectorAll(".focused").forEach(e => {
        e.classList.remove("focused");
      }), this.grid.children[e].classList.add("focused");
    }
  }
  class ce extends de {
    constructor(e) {
      super(e, {
        id: 0,
        name: "days",
        cellClass: "day"
      });
    }
    init(e, t = !0) {
      if (t) {
        const e = L(re).firstChild;
        this.dow = e.firstChild, this.grid = e.lastChild, this.element.appendChild(e);
      }
      super.init(e);
    }
    setOptions(e) {
      let t;
      if ("minDate" in e && (this.minDate = e.minDate), "maxDate" in e && (this.maxDate = e.maxDate), e.checkDisabled && (this.checkDisabled = e.checkDisabled), e.daysOfWeekDisabled && (this.daysOfWeekDisabled = e.daysOfWeekDisabled, t = !0), e.daysOfWeekHighlighted && (this.daysOfWeekHighlighted = e.daysOfWeekHighlighted), "todayHighlight" in e && (this.todayHighlight = e.todayHighlight), "weekStart" in e && (this.weekStart = e.weekStart, this.weekEnd = e.weekEnd, t = !0), e.locale) {
        const i = this.locale = e.locale;
        this.dayNames = i.daysMin, this.switchLabelFormat = i.titleFormat, t = !0;
      }
      if ("beforeShowDay" in e && (this.beforeShow = "function" == typeof e.beforeShowDay ? e.beforeShowDay : void 0), "weekNumbers" in e) if (e.weekNumbers && !this.weekNumbers) {
        const e = L(oe).firstChild;
        this.weekNumbers = {
          element: e,
          dow: e.firstChild,
          weeks: e.lastChild
        }, this.element.insertBefore(e, this.element.firstChild);
      } else this.weekNumbers && !e.weekNumbers && (this.element.removeChild(this.weekNumbers.element), this.weekNumbers = null);
      "getWeekNumber" in e && (this.getWeekNumber = e.getWeekNumber), "showDaysOfWeek" in e && (e.showDaysOfWeek ? (K(this.dow), this.weekNumbers && K(this.weekNumbers.dow)) : (W(this.dow), this.weekNumbers && W(this.weekNumbers.dow))), t && Array.from(this.dow.children).forEach((e, t) => {
        const i = (this.weekStart + t) % 7;
        e.textContent = this.dayNames[i], e.className = this.daysOfWeekDisabled.includes(i) ? "dow disabled" : "dow";
      });
    }
    updateFocus() {
      const e = new Date(this.picker.viewDate),
        t = e.getFullYear(),
        i = e.getMonth(),
        n = c(t, i, 1),
        s = p(n, this.weekStart, this.weekStart);
      this.first = n, this.last = c(t, i + 1, 0), this.start = s, this.focused = this.picker.viewDate;
    }
    updateSelection() {
      const {
        dates: e,
        rangepicker: t
      } = this.picker.datepicker;
      this.selected = e, t && (this.range = t.dates);
    }
    render() {
      if (this.today = this.todayHighlight ? d() : void 0, this.prepareForRender(B(this.focused, this.switchLabelFormat, this.locale), this.first <= this.minDate, this.last >= this.maxDate), this.weekNumbers) {
        const e = this.weekStart,
          t = p(this.first, e, e);
        Array.from(this.weekNumbers.weeks.children).forEach((i, n) => {
          const s = l(t, 7 * n);
          i.textContent = this.getWeekNumber(s, e), n > 3 && i.classList[s > this.last ? "add" : "remove"]("next");
        });
      }
      Array.from(this.grid.children).forEach((e, t) => {
        const i = l(this.start, t),
          n = new Date(i),
          s = n.getDay(),
          a = [];
        this.today === i && a.push("today"), this.daysOfWeekHighlighted.includes(s) && a.push("highlighted"), this.renderCell(e, n.getDate(), i, i, this, i < this.minDate || i > this.maxDate || this.daysOfWeekDisabled.includes(s), a);
      });
    }
    refresh() {
      const e = this.range || [];
      Array.from(this.grid.children).forEach(t => {
        this.refreshCell(t, Number(t.dataset.date), this.selected, e);
      });
    }
    refreshFocus() {
      this.changeFocusedCell(Math.round((this.focused - this.start) / 864e5));
    }
  }
  function le(e, t) {
    if (!e || !e[0] || !e[1]) return;
    const [[i, n], [s, a]] = e;
    return i > t || s < t ? void 0 : [i === t ? n : -1, s === t ? a : 12];
  }
  class he extends de {
    constructor(e) {
      super(e, {
        id: 1,
        name: "months",
        cellClass: "month"
      });
    }
    init(e, t = !0) {
      t && (this.grid = this.element, this.element.classList.add("months", "datepicker-grid"), this.grid.appendChild(L(a("span", 12, {
        "data-month": e => e
      }))), this.first = 0, this.last = 11), super.init(e);
    }
    setOptions(e) {
      if (e.locale && (this.monthNames = e.locale.monthsShort), "minDate" in e) if (void 0 === e.minDate) this.minYear = this.minMonth = this.minDate = void 0;else {
        const t = new Date(e.minDate);
        this.minYear = t.getFullYear(), this.minMonth = t.getMonth(), this.minDate = t.setDate(1);
      }
      if ("maxDate" in e) if (void 0 === e.maxDate) this.maxYear = this.maxMonth = this.maxDate = void 0;else {
        const t = new Date(e.maxDate);
        this.maxYear = t.getFullYear(), this.maxMonth = t.getMonth(), this.maxDate = c(this.maxYear, this.maxMonth + 1, 0);
      }
      e.checkDisabled && (this.checkDisabled = this.isMinView || null === e.datesDisabled ? e.checkDisabled : () => !1), "beforeShowMonth" in e && (this.beforeShow = "function" == typeof e.beforeShowMonth ? e.beforeShowMonth : void 0);
    }
    updateFocus() {
      const e = new Date(this.picker.viewDate);
      this.year = e.getFullYear(), this.focused = e.getMonth();
    }
    updateSelection() {
      const {
        dates: e,
        rangepicker: i
      } = this.picker.datepicker;
      this.selected = e.reduce((e, i) => {
        const n = new Date(i),
          s = n.getFullYear(),
          a = n.getMonth();
        return void 0 === e[s] ? e[s] = [a] : t(e[s], a), e;
      }, {}), i && i.dates && (this.range = i.dates.map(e => {
        const t = new Date(e);
        return isNaN(t) ? void 0 : [t.getFullYear(), t.getMonth()];
      }));
    }
    render() {
      this.prepareForRender(this.year, this.year <= this.minYear, this.year >= this.maxYear);
      const e = this.selected[this.year] || [],
        t = this.year < this.minYear || this.year > this.maxYear,
        i = this.year === this.minYear,
        n = this.year === this.maxYear,
        s = le(this.range, this.year);
      Array.from(this.grid.children).forEach((a, r) => {
        const o = b(new Date(this.year, r, 1), 1, this.isRangeEnd);
        this.renderCell(a, this.monthNames[r], r, o, {
          selected: e,
          range: s
        }, t || i && r < this.minMonth || n && r > this.maxMonth);
      });
    }
    refresh() {
      const e = this.selected[this.year] || [],
        t = le(this.range, this.year) || [];
      Array.from(this.grid.children).forEach((i, n) => {
        this.refreshCell(i, n, e, t);
      });
    }
    refreshFocus() {
      this.changeFocusedCell(this.focused);
    }
  }
  class ue extends de {
    constructor(e, t) {
      super(e, t);
    }
    init(e, t = !0) {
      var i;
      t && (this.navStep = 10 * this.step, this.beforeShowOption = `beforeShow${(i = this.cellClass, [...i].reduce((e, t, i) => e + (i ? t : t.toUpperCase()), ""))}`, this.grid = this.element, this.element.classList.add(this.name, "datepicker-grid"), this.grid.appendChild(L(a("span", 12)))), super.init(e);
    }
    setOptions(e) {
      if ("minDate" in e && (void 0 === e.minDate ? this.minYear = this.minDate = void 0 : (this.minYear = k(e.minDate, this.step), this.minDate = c(this.minYear, 0, 1))), "maxDate" in e && (void 0 === e.maxDate ? this.maxYear = this.maxDate = void 0 : (this.maxYear = k(e.maxDate, this.step), this.maxDate = c(this.maxYear, 11, 31))), e.checkDisabled && (this.checkDisabled = this.isMinView || null === e.datesDisabled ? e.checkDisabled : () => !1), this.beforeShowOption in e) {
        const t = e[this.beforeShowOption];
        this.beforeShow = "function" == typeof t ? t : void 0;
      }
    }
    updateFocus() {
      const e = new Date(this.picker.viewDate),
        t = k(e, this.navStep),
        i = t + 9 * this.step;
      this.first = t, this.last = i, this.start = t - this.step, this.focused = k(e, this.step);
    }
    updateSelection() {
      const {
        dates: e,
        rangepicker: i
      } = this.picker.datepicker;
      this.selected = e.reduce((e, i) => t(e, k(i, this.step)), []), i && i.dates && (this.range = i.dates.map(e => {
        if (void 0 !== e) return k(e, this.step);
      }));
    }
    render() {
      this.prepareForRender(`${this.first}-${this.last}`, this.first <= this.minYear, this.last >= this.maxYear), Array.from(this.grid.children).forEach((e, t) => {
        const i = this.start + t * this.step,
          n = b(new Date(i, 0, 1), 2, this.isRangeEnd);
        e.dataset.year = i, this.renderCell(e, i, i, n, this, i < this.minYear || i > this.maxYear);
      });
    }
    refresh() {
      const e = this.range || [];
      Array.from(this.grid.children).forEach(t => {
        this.refreshCell(t, Number(t.textContent), this.selected, e);
      });
    }
    refreshFocus() {
      this.changeFocusedCell(Math.round((this.focused - this.start) / this.step));
    }
  }
  function fe(e, t) {
    const i = {
      bubbles: !0,
      cancelable: !0,
      detail: {
        date: e.getDate(),
        viewDate: new Date(e.picker.viewDate),
        viewId: e.picker.currentView.id,
        datepicker: e
      }
    };
    e.element.dispatchEvent(new CustomEvent(t, i));
  }
  function pe(e, t) {
    const {
        config: i,
        picker: n
      } = e,
      {
        currentView: a,
        viewDate: r
      } = n;
    let o;
    switch (a.id) {
      case 0:
        o = h(r, t);
        break;
      case 1:
        o = u(r, t);
        break;
      default:
        o = u(r, t * a.navStep);
    }
    o = s(o, i.minDate, i.maxDate), n.changeFocus(o).render();
  }
  function me(e) {
    const t = e.picker.currentView.id;
    t !== e.config.maxView && e.picker.changeView(t + 1).render();
  }
  function we(e) {
    e.setDate({
      clear: !0
    });
  }
  function ge(e) {
    const t = d();
    1 === e.config.todayButtonMode ? e.setDate(t, {
      forceRefresh: !0,
      viewDate: t
    }) : e.setFocusedDate(t, !0);
  }
  function ye(e) {
    const t = () => {
        e.config.updateOnBlur ? e.update({
          revert: !0
        }) : e.refresh("input"), e.hide();
      },
      i = e.element;
    Y(i) ? i.addEventListener("blur", t, {
      once: !0
    }) : t();
  }
  function De(e, t) {
    const i = e.picker,
      n = new Date(i.viewDate),
      s = i.currentView.id,
      a = 1 === s ? h(n, t - n.getMonth()) : u(n, t - n.getFullYear());
    i.changeFocus(a).changeView(s - 1).render();
  }
  function ke(e) {
    me(e);
  }
  function be(e) {
    pe(e, -1);
  }
  function ve(e) {
    pe(e, 1);
  }
  function xe(e, t) {
    const i = I(t, ".datepicker-cell");
    if (!i || i.classList.contains("disabled")) return;
    const {
        id: n,
        isMinView: s
      } = e.picker.currentView,
      a = i.dataset;
    s ? e.setDate(Number(a.date)) : De(e, Number(1 === n ? a.month : a.year));
  }
  function Me(e) {
    e.preventDefault();
  }
  const Ne = ["left", "top", "right", "bottom"].reduce((e, t) => (e[t] = `datepicker-orient-${t}`, e), {}),
    Se = e => e ? `${e}px` : e;
  function Oe(e, t) {
    if ("title" in t && (t.title ? (e.controls.title.textContent = t.title, K(e.controls.title)) : (e.controls.title.textContent = "", W(e.controls.title))), t.prevArrow) {
      const i = e.controls.prevButton;
      _(i), t.prevArrow.forEach(e => {
        i.appendChild(e.cloneNode(!0));
      });
    }
    if (t.nextArrow) {
      const i = e.controls.nextButton;
      _(i), t.nextArrow.forEach(e => {
        i.appendChild(e.cloneNode(!0));
      });
    }
    if (t.locale && (e.controls.todayButton.textContent = t.locale.today, e.controls.clearButton.textContent = t.locale.clear), "todayButton" in t && (t.todayButton ? K(e.controls.todayButton) : W(e.controls.todayButton)), "minDate" in t || "maxDate" in t) {
      const {
        minDate: t,
        maxDate: i
      } = e.datepicker.config;
      e.controls.todayButton.disabled = !n(d(), t, i);
    }
    "clearButton" in t && (t.clearButton ? K(e.controls.clearButton) : W(e.controls.clearButton));
  }
  function Ce(t) {
    const {
      dates: i,
      config: n,
      rangeSideIndex: a
    } = t;
    return s(i.length > 0 ? e(i) : b(n.defaultViewDate, n.pickLevel, a), n.minDate, n.maxDate);
  }
  function Fe(e, t) {
    "_oldViewDate" in e || t === e.viewDate || (e._oldViewDate = e.viewDate), e.viewDate = t;
    const {
        id: i,
        year: n,
        first: s,
        last: a
      } = e.currentView,
      r = new Date(t).getFullYear();
    switch (i) {
      case 0:
        return t < s || t > a;
      case 1:
        return r !== n;
      default:
        return r < s || r > a;
    }
  }
  function Ve(e) {
    return window.getComputedStyle(e).direction;
  }
  function Be(e) {
    const t = A(e);
    if (t !== document.body && t) return "visible" !== window.getComputedStyle(t).overflow ? t : Be(t);
  }
  class Ee {
    constructor(e) {
      const {
          config: t,
          inputField: i
        } = this.datepicker = e,
        n = ae.replace(/%buttonClass%/g, t.buttonClass),
        s = this.element = L(n).firstChild,
        [a, r, o] = s.firstChild.children,
        d = a.firstElementChild,
        [c, l, h] = a.lastElementChild.children,
        [u, f] = o.firstChild.children,
        p = {
          title: d,
          prevButton: c,
          viewSwitch: l,
          nextButton: h,
          todayButton: u,
          clearButton: f
        };
      this.main = r, this.controls = p;
      const m = i ? "dropdown" : "inline";
      s.classList.add(`datepicker-${m}`), Oe(this, t), this.viewDate = Ce(e), R(e, [[s, "mousedown", Me], [r, "click", xe.bind(null, e)], [p.viewSwitch, "click", ke.bind(null, e)], [p.prevButton, "click", be.bind(null, e)], [p.nextButton, "click", ve.bind(null, e)], [p.todayButton, "click", ge.bind(null, e)], [p.clearButton, "click", we.bind(null, e)]]), this.views = [new ce(this), new he(this), new ue(this, {
        id: 2,
        name: "years",
        cellClass: "year",
        step: 1
      }), new ue(this, {
        id: 3,
        name: "decades",
        cellClass: "decade",
        step: 10
      })], this.currentView = this.views[t.startView], this.currentView.render(), this.main.appendChild(this.currentView.element), t.container ? t.container.appendChild(this.element) : i.after(this.element);
    }
    setOptions(e) {
      Oe(this, e), this.views.forEach(t => {
        t.init(e, !1);
      }), this.currentView.render();
    }
    detach() {
      this.element.remove();
    }
    show() {
      if (this.active) return;
      const {
          datepicker: e,
          element: t
        } = this,
        i = e.inputField;
      if (i) {
        const n = Ve(i);
        n !== Ve(A(t)) ? t.dir = n : t.dir && t.removeAttribute("dir"), this.place(), t.classList.add("active"), e.config.disableTouchKeyboard && i.blur();
      } else t.classList.add("active");
      this.active = !0, fe(e, "show");
    }
    hide() {
      this.active && (this.datepicker.exitEditMode(), this.element.classList.remove("active"), this.active = !1, fe(this.datepicker, "hide"));
    }
    place() {
      const {
        classList: e,
        style: t
      } = this.element;
      t.display = "block";
      const {
          width: i,
          height: n
        } = this.element.getBoundingClientRect(),
        s = this.element.offsetParent;
      t.display = "";
      const {
          config: a,
          inputField: r
        } = this.datepicker,
        {
          left: o,
          top: d,
          right: c,
          bottom: l,
          width: h,
          height: u
        } = r.getBoundingClientRect();
      let {
          x: f,
          y: p
        } = a.orientation,
        m = o,
        w = d;
      if (s !== document.body && s) {
        const e = s.getBoundingClientRect();
        m -= e.left - s.scrollLeft, w -= e.top - s.scrollTop;
      } else m += window.scrollX, w += window.scrollY;
      const g = Be(r);
      let y = 0,
        D = 0,
        {
          clientWidth: k,
          clientHeight: b
        } = document.documentElement;
      if (g) {
        const e = g.getBoundingClientRect();
        e.top > 0 && (D = e.top), e.left > 0 && (y = e.left), e.right < k && (k = e.right), e.bottom < b && (b = e.bottom);
      }
      let v = 0;
      "auto" === f && (o < y ? (f = "left", v = y - o) : o + i > k ? (f = "right", k < c && (v = k - c)) : f = "rtl" === Ve(r) ? c - i < y ? "left" : "right" : "left"), "right" === f && (m += h - i), m += v, "auto" === p && (p = d - n > D && l + n > b ? "top" : "bottom"), "top" === p ? w -= n : w += u, e.remove(...Object.values(Ne)), e.add(Ne[f], Ne[p]), t.left = Se(m), t.top = Se(w);
    }
    setViewSwitchLabel(e) {
      this.controls.viewSwitch.textContent = e;
    }
    setPrevButtonDisabled(e) {
      this.controls.prevButton.disabled = e;
    }
    setNextButtonDisabled(e) {
      this.controls.nextButton.disabled = e;
    }
    changeView(e) {
      const t = this.currentView;
      return e !== t.id && (this._oldView || (this._oldView = t), this.currentView = this.views[e], this._renderMethod = "render"), this;
    }
    changeFocus(e) {
      return this._renderMethod = Fe(this, e) ? "render" : "refreshFocus", this.views.forEach(e => {
        e.updateFocus();
      }), this;
    }
    update(e = void 0) {
      const t = void 0 === e ? Ce(this.datepicker) : e;
      return this._renderMethod = Fe(this, t) ? "render" : "refresh", this.views.forEach(e => {
        e.updateFocus(), e.updateSelection();
      }), this;
    }
    render(e = !0) {
      const {
          currentView: t,
          datepicker: i,
          _oldView: n
        } = this,
        s = new Date(this._oldViewDate),
        a = e && this._renderMethod || "render";
      if (delete this._oldView, delete this._oldViewDate, delete this._renderMethod, t[a](), n && (this.main.replaceChild(t.element, n.element), fe(i, "changeView")), !isNaN(s)) {
        const e = new Date(this.viewDate);
        e.getFullYear() !== s.getFullYear() && fe(i, "changeYear"), e.getMonth() !== s.getMonth() && fe(i, "changeMonth");
      }
    }
  }
  function Le(e, t, i, s, a, r) {
    if (n(e, a, r)) {
      if (s(e)) {
        return Le(t(e, i), t, i, s, a, r);
      }
      return e;
    }
  }
  function Ae(e, t, i) {
    const n = e.picker,
      s = n.currentView,
      a = s.step || 1;
    let r,
      o = n.viewDate;
    switch (s.id) {
      case 0:
        o = l(o, i ? 7 * t : t), r = l;
        break;
      case 1:
        o = h(o, i ? 4 * t : t), r = h;
        break;
      default:
        o = u(o, t * (i ? 4 : 1) * a), r = u;
    }
    o = Le(o, r, t < 0 ? -a : a, e => s.disabled.includes(e), s.minDate, s.maxDate), void 0 !== o && n.changeFocus(o).render();
  }
  function Ye(e, t) {
    const {
        config: i,
        picker: n,
        editMode: s
      } = e,
      a = n.active,
      {
        key: r,
        altKey: o,
        shiftKey: d
      } = t,
      c = t.ctrlKey || t.metaKey,
      l = () => {
        t.preventDefault(), t.stopPropagation();
      };
    if ("Tab" === r) return void ye(e);
    if ("Enter" === r) {
      if (a) {
        if (s) e.exitEditMode({
          update: !0,
          autohide: i.autohide
        });else {
          const t = n.currentView;
          t.isMinView ? e.setDate(n.viewDate) : (n.changeView(t.id - 1).render(), l());
        }
      } else e.update();
      return;
    }
    const h = i.shortcutKeys,
      u = {
        key: r,
        ctrlOrMetaKey: c,
        altKey: o,
        shiftKey: d
      },
      f = Object.keys(h).find(e => {
        const t = h[e];
        return !Object.keys(t).find(e => t[e] !== u[e]);
      });
    if (f) {
      let t;
      if ("toggle" === f ? t = f : s ? "exitEditMode" === f && (t = f) : a ? "hide" === f ? t = f : "prevButton" === f ? t = [pe, [e, -1]] : "nextButton" === f ? t = [pe, [e, 1]] : "viewSwitch" === f ? t = [me, [e]] : i.clearButton && "clearButton" === f ? t = [we, [e]] : i.todayButton && "todayButton" === f && (t = [ge, [e]]) : "show" === f && (t = f), t) return Array.isArray(t) ? t[0].apply(null, t[1]) : e[t](), void l();
    }
    if (!a || s) return;
    const p = (i, n) => {
      d || c || o ? e.enterEditMode() : (Ae(e, i, n), t.preventDefault());
    };
    "ArrowLeft" === r ? p(-1, !1) : "ArrowRight" === r ? p(1, !1) : "ArrowUp" === r ? p(-1, !0) : "ArrowDown" === r ? p(1, !0) : ("Backspace" === r || "Delete" === r || r && 1 === r.length && !c) && e.enterEditMode();
  }
  function We(e) {
    e.config.showOnFocus && !e._showing && e.show();
  }
  function Ke(e, t) {
    const i = t.target;
    (e.picker.active || e.config.showOnClick) && (i._active = Y(i), i._clicking = setTimeout(() => {
      delete i._active, delete i._clicking;
    }, 2e3));
  }
  function _e(e, t) {
    const i = t.target;
    i._clicking && (clearTimeout(i._clicking), delete i._clicking, i._active && e.enterEditMode(), delete i._active, e.config.showOnClick && e.show());
  }
  function Te(e, t) {
    t.clipboardData.types.includes("text/plain") && e.enterEditMode();
  }
  function He(e, t) {
    const {
      element: i,
      picker: n
    } = e;
    if (!n.active && !Y(i)) return;
    const s = n.element;
    I(t, e => e === i || e === s) || ye(e);
  }
  function je(e, t) {
    return e.map(e => B(e, t.format, t.locale)).join(t.dateDelimiter);
  }
  function Re(e, t, i = !1) {
    if (0 === t.length) return i ? [] : void 0;
    const {
        config: s,
        dates: a,
        rangeSideIndex: r
      } = e,
      {
        pickLevel: o,
        maxNumberOfDates: d
      } = s;
    let c = t.reduce((e, t) => {
      let i = V(t, s.format, s.locale);
      return void 0 === i || (i = b(i, o, r), !n(i, s.minDate, s.maxDate) || e.includes(i) || s.checkDisabled(i, o) || !(o > 0) && s.daysOfWeekDisabled.includes(new Date(i).getDay()) || e.push(i)), e;
    }, []);
    return 0 !== c.length ? (s.multidate && !i && (c = c.reduce((e, t) => (a.includes(t) || e.push(t), e), a.filter(e => !c.includes(e)))), d && c.length > d ? c.slice(-1 * d) : c) : void 0;
  }
  function $e(e, t = 3, i = !0, n = void 0) {
    const {
      config: s,
      picker: a,
      inputField: r
    } = e;
    if (2 & t) {
      const e = a.active ? s.pickLevel : s.startView;
      a.update(n).changeView(e).render(i);
    }
    1 & t && r && (r.value = je(e.dates, s));
  }
  function Ie(e, t, i) {
    const n = e.config;
    let {
      clear: s,
      render: a,
      autohide: r,
      revert: o,
      forceRefresh: d,
      viewDate: c
    } = i;
    void 0 === a && (a = !0), a ? void 0 === r && (r = n.autohide) : r = d = !1, c = V(c, n.format, n.locale);
    const l = Re(e, t, s);
    (l || o) && (l && l.toString() !== e.dates.toString() ? (e.dates = l, $e(e, a ? 3 : 1, !0, c), fe(e, "changeDate")) : $e(e, d ? 3 : 1, !0, c), r && e.hide());
  }
  function Pe(e, t) {
    return t ? i => B(i, t, e.config.locale) : e => new Date(e);
  }
  return class {
    constructor(e, t = {}, n = void 0) {
      e.datepicker = this, this.element = e, this.dates = [];
      const s = this.config = Object.assign({
        buttonClass: t.buttonClass && String(t.buttonClass) || "button",
        container: null,
        defaultViewDate: d(),
        maxDate: void 0,
        minDate: void 0
      }, ie(J, this));
      let a;
      if ("INPUT" === e.tagName ? (a = this.inputField = e, a.classList.add("datepicker-input"), t.container && (s.container = t.container instanceof HTMLElement ? t.container : document.querySelector(t.container))) : s.container = e, n) {
        const e = n.inputs.indexOf(a),
          t = n.datepickers;
        if (e < 0 || e > 1 || !Array.isArray(t)) throw Error("Invalid rangepicker object.");
        t[e] = this, this.rangepicker = n, this.rangeSideIndex = e;
      }
      this._options = t, Object.assign(s, ie(t, this)), s.shortcutKeys = function (e) {
        return Object.keys(ne).reduce((t, i) => {
          const n = void 0 === e[i] ? ne[i] : e[i],
            s = n && n.key;
          if (!s || "string" != typeof s) return t;
          const a = {
            key: s,
            ctrlOrMetaKey: !!(n.ctrlOrMetaKey || n.ctrlKey || n.metaKey)
          };
          return s.length > 1 && (a.altKey = !!n.altKey, a.shiftKey = !!n.shiftKey), t[i] = a, t;
        }, {});
      }(t.shortcutKeys || {});
      const r = i(e.value || e.dataset.date, s.dateDelimiter);
      delete e.dataset.date;
      const o = Re(this, r);
      o && o.length > 0 && (this.dates = o), a && (a.value = je(this.dates, s));
      const c = this.picker = new Ee(this),
        l = [e, "keydown", Ye.bind(null, this)];
      a ? R(this, [l, [a, "focus", We.bind(null, this)], [a, "mousedown", Ke.bind(null, this)], [a, "click", _e.bind(null, this)], [a, "paste", Te.bind(null, this)], [document, "mousedown", He.bind(null, this)], [window, "resize", c.place.bind(c)]]) : (R(this, [l]), this.show());
    }
    static formatDate(e, t, i) {
      return B(e, t, i && P[i] || P.en);
    }
    static parseDate(e, t, i) {
      return V(e, t, i && P[i] || P.en);
    }
    static get locales() {
      return P;
    }
    get active() {
      return !(!this.picker || !this.picker.active);
    }
    get pickerElement() {
      return this.picker ? this.picker.element : void 0;
    }
    setOptions(e) {
      const t = ie(e, this);
      Object.assign(this._options, e), Object.assign(this.config, t), this.picker.setOptions(t), $e(this, 3);
    }
    show() {
      if (this.inputField) {
        const {
          config: e,
          inputField: t
        } = this;
        if (t.disabled || t.readOnly && !e.enableOnReadonly) return;
        Y(t) || e.disableTouchKeyboard || (this._showing = !0, t.focus(), delete this._showing);
      }
      this.picker.show();
    }
    hide() {
      this.inputField && (this.picker.hide(), this.picker.update().changeView(this.config.startView).render());
    }
    toggle() {
      this.picker.active ? this.inputField && this.picker.hide() : this.show();
    }
    destroy() {
      this.hide(), function (e) {
        let t = T.get(e);
        t && (t.forEach(e => {
          j.call(...e);
        }), T.delete(e));
      }(this), this.picker.detach();
      const e = this.element;
      return e.classList.remove("datepicker-input"), delete e.datepicker, this;
    }
    getDate(e = void 0) {
      const t = Pe(this, e);
      return this.config.multidate ? this.dates.map(t) : this.dates.length > 0 ? t(this.dates[0]) : void 0;
    }
    setDate(...t) {
      const i = [...t],
        n = {},
        s = e(t);
      !s || "object" != typeof s || Array.isArray(s) || s instanceof Date || Object.assign(n, i.pop());
      Ie(this, Array.isArray(i[0]) ? i[0] : i, n);
    }
    update(e = void 0) {
      if (!this.inputField) return;
      const t = Object.assign(e || {}, {
        clear: !0,
        render: !0,
        viewDate: void 0
      });
      Ie(this, i(this.inputField.value, this.config.dateDelimiter), t);
    }
    getFocusedDate(e = void 0) {
      return Pe(this, e)(this.picker.viewDate);
    }
    setFocusedDate(e, t = !1) {
      const {
          config: i,
          picker: n,
          active: s,
          rangeSideIndex: a
        } = this,
        r = i.pickLevel,
        o = V(e, i.format, i.locale);
      void 0 !== o && (n.changeFocus(b(o, r, a)), s && t && n.changeView(r), n.render());
    }
    refresh(e = void 0, t = !1) {
      let i;
      e && "string" != typeof e && (t = e, e = void 0), i = "picker" === e ? 2 : "input" === e ? 1 : 3, $e(this, i, !t);
    }
    enterEditMode() {
      const e = this.inputField;
      e && !e.readOnly && this.picker.active && !this.editMode && (this.editMode = !0, e.classList.add("in-edit"));
    }
    exitEditMode(e = void 0) {
      if (!this.inputField || !this.editMode) return;
      const t = Object.assign({
        update: !1
      }, e);
      delete this.editMode, this.inputField.classList.remove("in-edit"), t.update && this.update(t);
    }
  };
}();
(function () {
  //const agreementElems = document.querySelectorAll('.contacts__agreement');
  const agreementElems = document.querySelectorAll('[class$="__agreement"]');
  for (let i = 0; i < agreementElems.length; i++) {
    let agreementElem = agreementElems[i];
    //const submitBtn = agreementElem.querySelector('.contacts__submit');
    const submitBtn = agreementElem.querySelector('button[type=submit]');
    const agreementCheckbox = agreementElem.querySelector('input[name=agreement]');
    if (agreementCheckbox) {
      agreementCheckbox.addEventListener('change', function (e) {
        if (!e.target.checked) {
          submitBtn.disabled = true;
        } else {
          submitBtn.disabled = false;
        }
      });
    }
  }
})();
(function () {
  //if (!autosize()) return;
  autosize(document.querySelectorAll('textarea'));
})();
document.addEventListener('DOMContentLoaded', function () {
  (function () {
    // указатель на текущую страницу
    var pagination = document.querySelector('.pagination');
    var btns = document.querySelectorAll('.pagination__item');
    Array.prototype.forEach.call(btns, function (item) {
      var link = item.children[0];
      if (item.classList.contains('active')) {
        link.setAttribute('aria-current', 'page');
      } else {
        link.removeAttribute('aria-current');
      }
    });
  })();
});
document.addEventListener('DOMContentLoaded', function () {
  var links = document.querySelectorAll('[href^="#"][data-scroll-link]');
  for (var i = 0; i < links.length; i++) {
    links[i].addEventListener('click', function (e) {
      var hash = this.href.replace(/[^#]*(.*)/, '$1');
      if (hash && hash !== '#') {
        e.preventDefault();
        var scroll = window.pageYOffset;
        var targetTop = getOffsetRect(document.querySelector(hash)).top - 10; // С поправкой в 10px
        var scrollDiff = (scroll - targetTop) * -1;
        animate({
          duration: 500,
          timing: function (timeFraction) {
            return Math.pow(timeFraction, 4); // https://learn.javascript.ru/js-animation
          },
          draw: function (progress) {
            var scrollNow = scroll + progress * scrollDiff;
            window.scrollTo(0, scrollNow);
          }
        });
      }
    }, false);
  }
  function animate(_ref) {
    var timing = _ref.timing,
      draw = _ref.draw,
      duration = _ref.duration;
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;
      var progress = timing(timeFraction);
      draw(progress);
      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }
    });
  }
  function getOffsetRect(elem) {
    var box = elem.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;
    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }
});
svg4everybody();
(function () {
  if (document.getElementById('toTop')) {
    document.getElementById('toTop').addEventListener('click', function (e) {
      e.preventDefault();
      var scroll = window.pageYOffset;
      var targetTop = 0;
      var scrollDiff = (scroll - targetTop) * -1;
      animate({
        duration: 500,
        timing: function (timeFraction) {
          return Math.pow(timeFraction, 4); // https://learn.javascript.ru/js-animation
        },
        draw: function (progress) {
          var scrollNow = scroll + progress * scrollDiff;
          window.scrollTo(0, scrollNow);
        }
      });
    }, false);
    window.addEventListener('scroll', visibilityToggle);
    visibilityToggle();
  }
  function visibilityToggle() {
    if (window.pageYOffset >= 500) {
      document.getElementById('toTop').classList.add('to-top--visible');
    } else {
      document.getElementById('toTop').classList.remove('to-top--visible');
    }
  }
  function animate(_ref) {
    var timing = _ref.timing,
      draw = _ref.draw,
      duration = _ref.duration;
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;
      var progress = timing(timeFraction);
      draw(progress);
      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }
    });
  }
})();
document.documentElement.className = document.documentElement.className.replace('no-js', 'js');
function cth(c) {
  document.documentElement.classList.add(c);
}
'ontouchstart' in window ? cth('touch') : cth('no-touch');
if (typeof InstallTrigger !== 'undefined') cth('firefox');
if (/constructor/i.test(window.HTMLElement) || function (p) {
  return p.toString() === "[object SafariRemoteNotification]";
}(!window['safari'] || typeof safari !== 'undefined' && safari.pushNotification)) cth('safari');
if ( /*@cc_on!@*/false || !!document.documentMode) cth('ie');
if (!( /*@cc_on!@*/false || !!document.documentMode) && !!window.StyleMedia) cth('edge');
if (!!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime)) cth('chrome');
if (~navigator.appVersion.indexOf("Win")) cth('windows');
if (~navigator.appVersion.indexOf("Mac")) cth('osx');
if (~navigator.appVersion.indexOf("Linux")) cth('linux');
(function () {
  // Поддержка формата webp для background-img
  // 1. Проверяем, можно ли использовать Webp формат
  function canUseWebp() {
    // Создаем элемент canvas
    let elem = document.createElement('canvas');
    // Приводим элемент к булеву типу
    if (!!(elem.getContext && elem.getContext('2d'))) {
      // Создаем изображение в формате webp, возвращаем индекс искомого элемента и сразу же проверяем его
      return elem.toDataURL('image/webp').indexOf('data:image/webp') == 0;
    }
    // Иначе Webp не используем
    return false;
  }
  // 2. Заменв формата изображений
  window.onload = function () {
    // Получаем все элементы с дата-атрибутом data-bg
    let images = document.querySelectorAll('[data-bg]');
    // Проходимся по каждому
    for (let i = 0; i < images.length; i++) {
      // Получаем значение каждого дата-атрибута
      let image = images[i].getAttribute('data-bg');
      // Каждому найденному элементу задаем свойство background-image с изображение формата jpg
      images[i].style.backgroundImage = 'url(' + image + ')';
    }
    // Проверяем, является ли браузер посетителя сайта Firefox и получаем его версию
    let isitFirefox = window.navigator.userAgent.match(/Firefox\/([0-9]+)\./);
    let firefoxVer = isitFirefox ? parseInt(isitFirefox[1]) : 0;
    // Если есть поддержка Webp или браузер Firefox версии больше или равно 65
    if (canUseWebp() || firefoxVer >= 65) {
      // Делаем все то же самое что и для jpg, но уже для изображений формата Webp
      let imagesWebp = document.querySelectorAll('[data-bg-webp]');
      for (let i = 0; i < imagesWebp.length; i++) {
        let imageWebp = imagesWebp[i].getAttribute('data-bg-webp');
        imagesWebp[i].style.backgroundImage = 'url(' + imageWebp + ')';
      }
    }
  };
  // Разметка:
  //<div style="background-image: url('/images/image.webp')" data-bg="/images/image.jpg" data-bg-webp="/images/image.webp"></div>
})();

// Если на проекте jQuery
// $( document ).ready(function() {
//   // code
// });

// Изоляция без jQuery
// (function(){
//   // code
// }());

// На проекте нет jQuery, но хочется $( document ).ready...
// function ready(fn) {
//   if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading"){
//     fn();
//   } else {
//     document.addEventListener('DOMContentLoaded', fn);
//   }
// }
//
// ready(function(){
//   // code
// });

// $(document).ready(function(){
//   if(window.matchMedia('(min-width: 1366px)').matches){
//   // do functionality on screens bigger than 1366px
//     $("#sticker").sticky({
//       topSpacing: 100
//     });
//   }
//   return false;
// });

/*(function () {
  //const agreementElems = document.querySelectorAll('.contacts__agreement');
  const agreementElems = document.querySelectorAll('[class$="__agreement"]');

  for (let i = 0; i < agreementElems.length; i++) {
    let agreementElem = agreementElems[i];
    if (!agreementElem) return;
    //const submitBtn = agreementElem.querySelector('.contacts__submit');
    const submitBtn = agreementElem.querySelector('button[type=submit]');
    const agreementCheckbox = agreementElem.querySelector('.agreement-field');

    if (agreementCheckbox) {
      agreementCheckbox.addEventListener('change', function (e) {
        if (!e.target.checked) {
          submitBtn.disabled = true;
        } else {
          submitBtn.disabled = false;
        }
      });
    }
  }

})();*/